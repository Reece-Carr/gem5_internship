//SLICC.ModularSLICC.dma.GenDMAHeader
machine(MachineType:DMA, "DMA (caching) controller")
: DMASequencer *dma_sequencer;
  CacheMemory *cache;

  // The following latencies should be exposed as command-line parameters in a future update
  Cycles responseLatency := 1;

  // Required networks
  MessageBuffer *mandatoryQueue;

  // Dynamic networks
  MessageBuffer *respTo, network="To", virtual_network="0", vnet_type="resp";
  MessageBuffer *respFrom, network="From", virtual_network="0", vnet_type="resp";
  MessageBuffer *fwdTo, network="To", virtual_network="1", vnet_type="fwd";
  MessageBuffer *fwdFrom, network="From", virtual_network="1", vnet_type="fwd";
  MessageBuffer *reqTo, network="To", virtual_network="2", vnet_type="req";
  MessageBuffer *reqFrom, network="From", virtual_network="2", vnet_type="req";

{
  //SLICC.ModularSLICC.dma.GenDMAStateDecl
  state_declaration(State, desc="DMA states", default="DMA_State_I") {
    I, AccessPermission:Invalid, desc="... TODO ...";
    I_load, AccessPermission:Invalid, desc="... TODO ...";
    I_store, AccessPermission:Invalid, desc="... TODO ...";
    I_store_GetM_Ack_AD, AccessPermission:Invalid, desc="... TODO ...";
    I_x_M_evict, AccessPermission:Invalid, desc="... TODO ...";
    I_x_O_evict, AccessPermission:Invalid, desc="... TODO ...";
    I_x_S_evict, AccessPermission:Invalid, desc="... TODO ...";
    M, AccessPermission:Read_Write, desc="... TODO ...";
    M_evict, AccessPermission:Invalid, desc="... TODO ...";
    O, AccessPermission:Read_Only, desc="... TODO ...";
    O_evict, AccessPermission:Invalid, desc="... TODO ...";
    O_store, AccessPermission:Invalid, desc="... TODO ...";
    O_store_GetM_Ack_AD, AccessPermission:Invalid, desc="... TODO ...";
    S, AccessPermission:Read_Only, desc="... TODO ...";
    S_evict, AccessPermission:Invalid, desc="... TODO ...";
    S_store, AccessPermission:Invalid, desc="... TODO ...";
    S_store_GetM_Ack_AD, AccessPermission:Invalid, desc="... TODO ...";
  }
  
  //SLICC.ModularSLICC.dma.GenDMAEvents
  enumeration(Event, desc="Cache events") {
    MloadMEvent, desc="M->M upon local load hit.";
    OloadOEvent, desc="O->O upon local load hit.";
    SloadSEvent, desc="S->S upon local load hit.";
    MstoreMEvent, desc="M->M upon local store hit.";
    externalloadMfwdfrom_in, desc="Remote load hit ending in state M. Should pop fwdfrom_in.";
    externalloadOfwdfrom_in, desc="Remote load hit ending in state O. Should pop fwdfrom_in.";
    externalloadSfwdfrom_in, desc="Remote load hit ending in state S. Should pop fwdfrom_in.";
    externalstoreMfwdfrom_in, desc="Remote store hit ending in state M. Should pop fwdfrom_in.";
    externalloadMreqfrom_in, desc="Remote load hit ending in state M. Should pop reqfrom_in.";
    externalloadOreqfrom_in, desc="Remote load hit ending in state O. Should pop reqfrom_in.";
    externalloadSreqfrom_in, desc="Remote load hit ending in state S. Should pop reqfrom_in.";
    externalstoreMreqfrom_in, desc="Remote store hit ending in state M. Should pop reqfrom_in.";
    externalloadMrespfrom_in, desc="Remote load hit ending in state M. Should pop respfrom_in.";
    externalloadOrespfrom_in, desc="Remote load hit ending in state O. Should pop respfrom_in.";
    externalloadSrespfrom_in, desc="Remote load hit ending in state S. Should pop respfrom_in.";
    externalstoreMrespfrom_in, desc="Remote store hit ending in state M. Should pop respfrom_in.";
    deallocfwdfrom_in, desc="Event indicating the cache line should be deallocated following a message received on fwdfrom_in.";
    deallocreqfrom_in, desc="Event indicating the cache line should be deallocated following a message received on reqfrom_in.";
    deallocrespfrom_in, desc="Event indicating the cache line should be deallocated following a message received on respfrom_in.";
    allocI_load, desc="Event indicating cache entry + tbe alloc before moving to I_load.";
    allocI_store, desc="Event indicating cache entry + tbe alloc before moving to I_store.";
    tbeAlloc, desc="Event indicating only TBE allocation. For DMA, the TBE is needed whena write misses locally to keep track of the length of the data to write (it may not bethe whole line).";
    Stall, desc="Stall, please!";
  }
  
  //SLICC.ModularSLICC.dma.GenDMAStruct
  structure(Entry, desc="Stored variables of the DMA machine", interface="AbstractCacheEntry") {
    State DMAState, desc="DMA state";
    DataBlock cl, desc="... TODO ...";
    int acksReceivedL1C1, default=0, desc="...TODO...";
    int acksExpectedL1C1, default=0, desc="...TODO...";
  }
  
  //SLICC.ModularSLICC.dma.GenDMATBE
  structure(TBE, desc="TBE entries for DMA controller") {
    Addr PhysicalAddress, desc="Physical address of the request";
    DataBlock DataBlk,    desc="Data to be written";
    int Len,              desc="Length of data to write";
  }
  
  structure(TBETable, external="yes"){
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
  }
  
  TBETable TBEs, template="<DMA_TBE>", constructor="m_number_of_TBEs";
  
  void set_tbe(TBE b);
  void unset_tbe();
  
  //SLICC.ModularSLICC.dma.GenDMAStaticFns
  Tick clockEdge();
  void set_cache_entry(AbstractCacheEntry a);
  void unset_cache_entry();
  
  MachineID mapAddressToMachine(Addr addr, MachineType mtype);
  
  Entry getDMAEntry(Addr LineAddress), return_by_pointer="yes" {
    return static_cast(Entry, "pointer", cache.lookup(LineAddress));
  }
  
  State getState(TBE tbe, Entry cache_entry, Addr LineAddress) {
    if (is_valid(cache_entry)) {
      return cache_entry.DMAState;
    } else {
      return State:I;
    }
  }
  
  void setState(TBE tbe, Entry cache_entry, Addr LineAddress, State state) {
    if (is_valid(cache_entry)) {
      cache_entry.DMAState := state;
    }
  }
  
  AccessPermission getAccessPermission(Addr LineAddress) {
    Entry cache_entry := getDMAEntry(LineAddress);
    if (is_valid(cache_entry)) {
      return DMA_State_to_permission(cache_entry.DMAState);
    } else {
      return AccessPermission:NotPresent;
    }
  }
  
  void setAccessPermission(Entry cache_entry, Addr LineAddress, State state) {
    if (is_valid(cache_entry)) {
      cache_entry.changePermission(DMA_State_to_permission(state));
    }
  }
  
  void functionalRead(Addr addr, Packet *pkt) {
      TBE tbe := TBEs[addr];
      if(is_valid(tbe)) {
          testAndRead(addr, tbe.DataBlk, pkt);
      } else {
          testAndRead(addr, getDMAEntry(addr).cl, pkt);
      }
  }
  
  int functionalWrite(Addr addr, Packet *pkt) {
      int num_functional_writes := 0;
  
      TBE tbe := TBEs[addr];
      if(is_valid(tbe)) {
          num_functional_writes := num_functional_writes +
              testAndWrite(addr, tbe.DataBlk, pkt);
          return num_functional_writes;
      }
  
      num_functional_writes := num_functional_writes +
              testAndWrite(addr, getDMAEntry(addr).cl, pkt);
      return num_functional_writes;
  }
  
  
  //SLICC.ModularSLICC.dma.GenDMAOutPorts
  out_port(fwdto_out, CoherenceMessage, fwdTo);
  out_port(reqto_out, CoherenceMessage, reqTo);
  out_port(respto_out, CoherenceMessage, respTo);
  
  //SLICC.ModularSLICC.dma.GenDMAInPorts
  in_port(respfrom_in, CoherenceMessage, respFrom) {
    if (respfrom_in.isReady(clockEdge())) {
      peek (respfrom_in, CoherenceMessage, block_on="LineAddress") {
        TBE tbe := TBEs[in_msg.LineAddress];
        Entry entry := getDMAEntry(in_msg.LineAddress);
        State st := getState(tbe, entry, in_msg.LineAddress);
        Addr LineAddress := in_msg.LineAddress;
        if (st == State:I) {
          trigger(Event:Stall, LineAddress, entry, tbe);
        } else if (st == State:I_load) {      
          if (in_msg.Type == CoherenceMessageType:GetS_AckL1C1) {
            entry.cl := in_msg.cl;
            setState(tbe, entry, LineAddress, State:S);
            trigger(Event:externalloadSrespfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_store) {      
          if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL1C1) {
            entry.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMrespfrom_in, LineAddress, entry, tbe);
            }
            else if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:I_store_GetM_Ack_AD);
              respfrom_in.dequeue(clockEdge());
            }  
          } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1C1) {
            entry.cl := in_msg.cl;
            setState(tbe, entry, LineAddress, State:M);
            trigger(Event:externalstoreMrespfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            setState(tbe, entry, LineAddress, State:I_store);
            respfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_store_GetM_Ack_AD) {      
          if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMrespfrom_in, LineAddress, entry, tbe);
            }
            else if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:I_store_GetM_Ack_AD);
              respfrom_in.dequeue(clockEdge());
            }
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_x_M_evict) {      
          if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocrespfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_x_O_evict) {      
          if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocrespfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_x_S_evict) {      
          if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocrespfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:M) {      
          if (in_msg.Type == CoherenceMessageType:M_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_DL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocrespfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:M_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O);
            respfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:M_evict) {      
          if (in_msg.Type == CoherenceMessageType:M_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_DL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:I_x_M_evict);
            respfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:M_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O_evict);
            respfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocrespfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O) {      
          if (in_msg.Type == CoherenceMessageType:O_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
              out_msg.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            }
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocrespfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O);
            respfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O_evict) {      
          if (in_msg.Type == CoherenceMessageType:O_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
              out_msg.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            }
            setState(tbe, entry, LineAddress, State:I_x_O_evict);
            respfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O_evict);
            respfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocrespfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O_store) {      
          if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL1C1) {
            entry.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMrespfrom_in, LineAddress, entry, tbe);
            }
            else if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:O_store_GetM_Ack_AD);
              respfrom_in.dequeue(clockEdge());
            }  
          } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1C1) {
            setState(tbe, entry, LineAddress, State:M);
            trigger(Event:externalstoreMrespfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            setState(tbe, entry, LineAddress, State:O_store);
            respfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
              out_msg.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            }
            setState(tbe, entry, LineAddress, State:I_store);
            respfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O_store);
            respfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O_store_GetM_Ack_AD) {      
          if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:O_store_GetM_Ack_AD);
              respfrom_in.dequeue(clockEdge());
            }
            else if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMrespfrom_in, LineAddress, entry, tbe);
            }
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S) {      
          if (in_msg.Type == CoherenceMessageType:InvL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Inv_AckL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocrespfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S_evict) {      
          if (in_msg.Type == CoherenceMessageType:InvL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Inv_AckL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, entry, LineAddress, State:I_x_S_evict);
            respfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocrespfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S_store) {      
          if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL1C1) {
            entry.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:S_store_GetM_Ack_AD);
              respfrom_in.dequeue(clockEdge());
            }
            else if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMrespfrom_in, LineAddress, entry, tbe);
            }  
          } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1C1) {
            setState(tbe, entry, LineAddress, State:M);
            trigger(Event:externalstoreMrespfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:InvL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Inv_AckL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, entry, LineAddress, State:I_store);
            respfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            setState(tbe, entry, LineAddress, State:S_store);
            respfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S_store_GetM_Ack_AD) {      
          if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:S_store_GetM_Ack_AD);
              respfrom_in.dequeue(clockEdge());
            }
            else if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMrespfrom_in, LineAddress, entry, tbe);
            }
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else {
          trigger(Event:Stall, LineAddress, entry, tbe);
        }
      }
    }
  }
  
  in_port(fwdfrom_in, CoherenceMessage, fwdFrom) {
    if (fwdfrom_in.isReady(clockEdge())) {
      peek (fwdfrom_in, CoherenceMessage, block_on="LineAddress") {
        TBE tbe := TBEs[in_msg.LineAddress];
        Entry entry := getDMAEntry(in_msg.LineAddress);
        State st := getState(tbe, entry, in_msg.LineAddress);
        Addr LineAddress := in_msg.LineAddress;
        if (st == State:I) {
          trigger(Event:Stall, LineAddress, entry, tbe);
        } else if (st == State:I_load) {      
          if (in_msg.Type == CoherenceMessageType:GetS_AckL1C1) {
            entry.cl := in_msg.cl;
            setState(tbe, entry, LineAddress, State:S);
            trigger(Event:externalloadSfwdfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_store) {      
          if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL1C1) {
            entry.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMfwdfrom_in, LineAddress, entry, tbe);
            }
            else if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:I_store_GetM_Ack_AD);
              fwdfrom_in.dequeue(clockEdge());
            }  
          } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1C1) {
            entry.cl := in_msg.cl;
            setState(tbe, entry, LineAddress, State:M);
            trigger(Event:externalstoreMfwdfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            setState(tbe, entry, LineAddress, State:I_store);
            fwdfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_store_GetM_Ack_AD) {      
          if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMfwdfrom_in, LineAddress, entry, tbe);
            }
            else if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:I_store_GetM_Ack_AD);
              fwdfrom_in.dequeue(clockEdge());
            }
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_x_M_evict) {      
          if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocfwdfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_x_O_evict) {      
          if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocfwdfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_x_S_evict) {      
          if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocfwdfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:M) {      
          if (in_msg.Type == CoherenceMessageType:M_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_DL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocfwdfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:M_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O);
            fwdfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:M_evict) {      
          if (in_msg.Type == CoherenceMessageType:M_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_DL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:I_x_M_evict);
            fwdfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:M_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O_evict);
            fwdfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocfwdfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O) {      
          if (in_msg.Type == CoherenceMessageType:O_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
              out_msg.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            }
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocfwdfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O);
            fwdfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O_evict) {      
          if (in_msg.Type == CoherenceMessageType:O_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
              out_msg.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            }
            setState(tbe, entry, LineAddress, State:I_x_O_evict);
            fwdfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O_evict);
            fwdfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocfwdfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O_store) {      
          if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL1C1) {
            entry.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMfwdfrom_in, LineAddress, entry, tbe);
            }
            else if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:O_store_GetM_Ack_AD);
              fwdfrom_in.dequeue(clockEdge());
            }  
          } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1C1) {
            setState(tbe, entry, LineAddress, State:M);
            trigger(Event:externalstoreMfwdfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            setState(tbe, entry, LineAddress, State:O_store);
            fwdfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
              out_msg.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            }
            setState(tbe, entry, LineAddress, State:I_store);
            fwdfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O_store);
            fwdfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O_store_GetM_Ack_AD) {      
          if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:O_store_GetM_Ack_AD);
              fwdfrom_in.dequeue(clockEdge());
            }
            else if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMfwdfrom_in, LineAddress, entry, tbe);
            }
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S) {      
          if (in_msg.Type == CoherenceMessageType:InvL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Inv_AckL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocfwdfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S_evict) {      
          if (in_msg.Type == CoherenceMessageType:InvL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Inv_AckL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, entry, LineAddress, State:I_x_S_evict);
            fwdfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocfwdfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S_store) {      
          if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL1C1) {
            entry.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:S_store_GetM_Ack_AD);
              fwdfrom_in.dequeue(clockEdge());
            }
            else if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMfwdfrom_in, LineAddress, entry, tbe);
            }  
          } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1C1) {
            setState(tbe, entry, LineAddress, State:M);
            trigger(Event:externalstoreMfwdfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:InvL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Inv_AckL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, entry, LineAddress, State:I_store);
            fwdfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            setState(tbe, entry, LineAddress, State:S_store);
            fwdfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S_store_GetM_Ack_AD) {      
          if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:S_store_GetM_Ack_AD);
              fwdfrom_in.dequeue(clockEdge());
            }
            else if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMfwdfrom_in, LineAddress, entry, tbe);
            }
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else {
          trigger(Event:Stall, LineAddress, entry, tbe);
        }
      }
    }
  }
  
  in_port(reqfrom_in, CoherenceMessage, reqFrom) {
    if (reqfrom_in.isReady(clockEdge())) {
      peek (reqfrom_in, CoherenceMessage, block_on="LineAddress") {
        TBE tbe := TBEs[in_msg.LineAddress];
        Entry entry := getDMAEntry(in_msg.LineAddress);
        State st := getState(tbe, entry, in_msg.LineAddress);
        Addr LineAddress := in_msg.LineAddress;
        if (st == State:I) {
          trigger(Event:Stall, LineAddress, entry, tbe);
        } else if (st == State:I_load) {      
          if (in_msg.Type == CoherenceMessageType:GetS_AckL1C1) {
            entry.cl := in_msg.cl;
            setState(tbe, entry, LineAddress, State:S);
            trigger(Event:externalloadSreqfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_store) {      
          if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL1C1) {
            entry.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMreqfrom_in, LineAddress, entry, tbe);
            }
            else if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:I_store_GetM_Ack_AD);
              reqfrom_in.dequeue(clockEdge());
            }  
          } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1C1) {
            entry.cl := in_msg.cl;
            setState(tbe, entry, LineAddress, State:M);
            trigger(Event:externalstoreMreqfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            setState(tbe, entry, LineAddress, State:I_store);
            reqfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_store_GetM_Ack_AD) {      
          if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMreqfrom_in, LineAddress, entry, tbe);
            }
            else if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:I_store_GetM_Ack_AD);
              reqfrom_in.dequeue(clockEdge());
            }
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_x_M_evict) {      
          if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocreqfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_x_O_evict) {      
          if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocreqfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:I_x_S_evict) {      
          if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocreqfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:M) {      
          if (in_msg.Type == CoherenceMessageType:M_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_DL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocreqfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:M_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O);
            reqfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:M_evict) {      
          if (in_msg.Type == CoherenceMessageType:M_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_DL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:I_x_M_evict);
            reqfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:M_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O_evict);
            reqfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocreqfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O) {      
          if (in_msg.Type == CoherenceMessageType:O_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
              out_msg.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            }
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocreqfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O);
            reqfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O_evict) {      
          if (in_msg.Type == CoherenceMessageType:O_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
              out_msg.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            }
            setState(tbe, entry, LineAddress, State:I_x_O_evict);
            reqfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O_evict);
            reqfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocreqfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O_store) {      
          if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL1C1) {
            entry.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMreqfrom_in, LineAddress, entry, tbe);
            }
            else if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:O_store_GetM_Ack_AD);
              reqfrom_in.dequeue(clockEdge());
            }  
          } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1C1) {
            setState(tbe, entry, LineAddress, State:M);
            trigger(Event:externalstoreMreqfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            setState(tbe, entry, LineAddress, State:O_store);
            reqfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetML1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetM_Ack_ADL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
              out_msg.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            }
            setState(tbe, entry, LineAddress, State:I_store);
            reqfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:O_Fwd_GetSL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:GetS_AckL1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O_store);
            reqfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:O_store_GetM_Ack_AD) {      
          if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:O_store_GetM_Ack_AD);
              reqfrom_in.dequeue(clockEdge());
            }
            else if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMreqfrom_in, LineAddress, entry, tbe);
            }
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S) {      
          if (in_msg.Type == CoherenceMessageType:InvL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Inv_AckL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocreqfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S_evict) {      
          if (in_msg.Type == CoherenceMessageType:InvL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Inv_AckL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, entry, LineAddress, State:I_x_S_evict);
            reqfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Put_AckL1C1) {
            setState(tbe, entry, LineAddress, State:I);
            trigger(Event:deallocreqfrom_in, LineAddress, entry, tbe);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S_store) {      
          if (in_msg.Type == CoherenceMessageType:GetM_Ack_ADL1C1) {
            entry.acksExpectedL1C1 := in_msg.acksExpectedL1C1;
            if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:S_store_GetM_Ack_AD);
              reqfrom_in.dequeue(clockEdge());
            }
            else if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMreqfrom_in, LineAddress, entry, tbe);
            }  
          } else if (in_msg.Type == CoherenceMessageType:GetM_Ack_DL1C1) {
            setState(tbe, entry, LineAddress, State:M);
            trigger(Event:externalstoreMreqfrom_in, LineAddress, entry, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:InvL1C1) {
            enqueue(respto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Inv_AckL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, entry, LineAddress, State:I_store);
            reqfrom_in.dequeue(clockEdge());  
          } else if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            setState(tbe, entry, LineAddress, State:S_store);
            reqfrom_in.dequeue(clockEdge());
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else if (st == State:S_store_GetM_Ack_AD) {      
          if (in_msg.Type == CoherenceMessageType:Inv_AckL1C1) {
            entry.acksReceivedL1C1 := entry.acksReceivedL1C1+1;
            if (entry.acksExpectedL1C1 != entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:S_store_GetM_Ack_AD);
              reqfrom_in.dequeue(clockEdge());
            }
            else if (entry.acksExpectedL1C1 == entry.acksReceivedL1C1) {
              setState(tbe, entry, LineAddress, State:M);
              trigger(Event:externalstoreMreqfrom_in, LineAddress, entry, tbe);
            }
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else {
          trigger(Event:Stall, LineAddress, entry, tbe);
        }
      }
    }
  }
  
  in_port(mandatory_in, SequencerMsg, mandatoryQueue) {
    if (mandatory_in.isReady(clockEdge())) {
      peek(mandatory_in, SequencerMsg, block_on="LineAddress") {
        Entry entry := getDMAEntry(in_msg.LineAddress);
        TBE tbe := TBEs[in_msg.LineAddress];
  
        if (is_invalid(entry) &&
            cache.cacheAvail(in_msg.LineAddress) == false ) {
          Addr LineAddress := cache.cacheProbe(in_msg.LineAddress);
          Entry entry := getDMAEntry(LineAddress);
          TBE tbe := TBEs[LineAddress];
          State st := getState(tbe, entry, LineAddress);
          if (st == State:S) {
            enqueue(reqto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
              out_msg.Type := CoherenceMessageType:PutSL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, entry, LineAddress, State:S_evict);
          } else if (st == State:O) {
            enqueue(reqto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
              out_msg.Type := CoherenceMessageType:PutML1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:O_evict);
          } else if (st == State:M) {
            enqueue(reqto_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
              out_msg.Type := CoherenceMessageType:PutML1C1;
              out_msg.Sender := machineID;
              out_msg.cl := entry.cl;
            }
            setState(tbe, entry, LineAddress, State:M_evict);
          } else {
            trigger(Event:Stall, LineAddress, entry, tbe);
          }
        } else {
          State st := getState(tbe, entry, in_msg.LineAddress);
          Addr LineAddress := in_msg.LineAddress;
          if (in_msg.Type == SequencerRequestType:LD) {
            if (st == State:I) {
              trigger(Event:allocI_load, LineAddress, entry, tbe);
            } else if (st == State:S) {
              setState(tbe, entry, LineAddress, State:S);trigger(Event:SloadSEvent, LineAddress, entry, tbe);
            } else if (st == State:O) {
              setState(tbe, entry, LineAddress, State:O);trigger(Event:OloadOEvent, LineAddress, entry, tbe);
            } else if (st == State:M) {
              setState(tbe, entry, LineAddress, State:M);trigger(Event:MloadMEvent, LineAddress, entry, tbe);
            } else {
              trigger(Event:Stall, LineAddress, entry, tbe);
            }
          } else if (in_msg.Type == SequencerRequestType:ST) {
            if (st == State:I) {
              trigger(Event:allocI_store, LineAddress, entry, tbe);
            } else if (st == State:S) {
              enqueue(reqto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:GetML1C1;
                out_msg.Sender := machineID;
              }
              setState(tbe, entry, LineAddress, State:S_store);
              setState(tbe, entry, LineAddress, State:S_store);
              setState(tbe, entry, LineAddress, State:S_store);trigger(Event:tbeAlloc, LineAddress, entry, tbe);
            } else if (st == State:O) {
              enqueue(reqto_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
                out_msg.Type := CoherenceMessageType:GetML1C1;
                out_msg.Sender := machineID;
              }
              entry.acksReceivedL1C1 := 0;
              setState(tbe, entry, LineAddress, State:O_store);
              setState(tbe, entry, LineAddress, State:O_store);
              setState(tbe, entry, LineAddress, State:O_store);trigger(Event:tbeAlloc, LineAddress, entry, tbe);
            } else if (st == State:M) {
              setState(tbe, entry, LineAddress, State:M);trigger(Event:MstoreMEvent, LineAddress, entry, tbe);
            } else {
              trigger(Event:Stall, LineAddress, entry, tbe);
            }
          } else {
            error("Unexpected message type from DMA");
          }
        }
      }
    }
  }
  
  //SLICC.ModularSLICC.dma.GenDMAActions
  action(deallocEntry, "d", desc="Deallocate an entry") {
      assert(is_valid(cache_entry));
      cache.deallocate(address);
      unset_cache_entry();
  }
  action(allocEntry, "a", desc="Allocate an entry") {
     assert(is_invalid(cache_entry));
     assert(cache.cacheAvail(address));
     set_cache_entry(cache.allocate(address, new Entry));
  }
  action(loadHit, "Lh", desc="Callback local or remote load hit.") {
    // Signal to gem5 that this DMA load/read has hit/finished
    assert(is_valid(cache_entry));
    cache.setMRU(cache_entry);
    dma_sequencer.dataCallback(cache_entry.cl, address);
  }
  action(storeHit, "Sh", desc="Callback local or remote store hit.") {
    // Signal to gem5 that this DMA load/read has hit/finished
    assert(is_valid(cache_entry));
    cache.setMRU(cache_entry);
    dma_sequencer.ackCallback(address);
  }
  action(allocPopulateTBE, "aTBE", desc="Allocate + populate TBE entry for DMA.") {
    TBEs.allocate(address);
    set_tbe(TBEs[address]);
    peek(mandatory_in, SequencerMsg) {
       tbe.DataBlk := in_msg.DataBlk;
       tbe.Len := in_msg.Len;
       tbe.PhysicalAddress := in_msg.PhysicalAddress;
    }
  }
  action(deallocTBE, "dTBE", desc="Deallocate DMA TBE entry.") {
    TBEs.deallocate(address);
    unset_tbe();
  }
  action(writePartial, "wP", desc="Perform a partial (DMA) write to a cache line from the TBE.") {
      cache_entry.cl.copyPartial(tbe.DataBlk,
                                  getOffset(tbe.PhysicalAddress),
                                  tbe.Len);
  }
  action(writePartialLocal, "wPL", desc="Perform a partial (DMA) write to a cache line from the Sequencer queue.") {
    peek(mandatory_in, SequencerMsg) {
      cache_entry.cl.copyPartial(in_msg.DataBlk,
                                  getOffset(in_msg.PhysicalAddress),
                                  in_msg.Len);
    }
  }
  action(popmandatory_in, "pmandatory_in0", desc="Pop the mandatory_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      mandatory_in.dequeue(clockEdge());
  }
  
  action(popfwdfrom_in, "pfwdfrom_in0", desc="Pop the fwdfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      fwdfrom_in.dequeue(clockEdge());
  }
  
  action(popreqfrom_in, "preqfrom_in0", desc="Pop the reqfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      reqfrom_in.dequeue(clockEdge());
  }
  
  action(poprespfrom_in, "prespfrom_in0", desc="Pop the respfrom_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      respfrom_in.dequeue(clockEdge());
  }
  
  action(actionI_I_load, "II0", desc="TODO") {
    peek(mandatory_in, SequencerMsg) {
      Entry entry := cache_entry;
      Addr LineAddress := in_msg.LineAddress;
      enqueue(reqto_out, CoherenceMessage, responseLatency) {
        out_msg.LineAddress := LineAddress;
        out_msg.MessageSize := MessageSizeType:Data;
        out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
        out_msg.Type := CoherenceMessageType:GetSL1C1;
        out_msg.Sender := machineID;
      }
      setState(tbe, entry, LineAddress, State:I_load);
    }
  }
  
  action(actionI_I_store, "II1", desc="TODO") {
    peek(mandatory_in, SequencerMsg) {
      Entry entry := cache_entry;
      Addr LineAddress := in_msg.LineAddress;
      enqueue(reqto_out, CoherenceMessage, responseLatency) {
        out_msg.LineAddress := LineAddress;
        out_msg.MessageSize := MessageSizeType:Data;
        out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));
        out_msg.Type := CoherenceMessageType:GetML1C1;
        out_msg.Sender := machineID;
      }
      entry.acksReceivedL1C1 := 0;
      setState(tbe, entry, LineAddress, State:I_store);
      setState(tbe, entry, LineAddress, State:I_store);
      setState(tbe, entry, LineAddress, State:I_store);
    }
  }
  
  action(stall, "s", desc="So called z-stall") {
      // z_stall
  }
  //SLICC.ModularSLICC.dma.GenDMATransitions
  transition({I}, deallocfwdfrom_in) {
      deallocEntry;
      popfwdfrom_in;
  }
  
  transition({I}, deallocreqfrom_in) {
      deallocEntry;
      popreqfrom_in;
  }
  
  transition({I}, deallocrespfrom_in) {
      deallocEntry;
      poprespfrom_in;
  }
  
  transition(I, allocI_load, I_load) {
      allocEntry;
      actionI_I_load;
      popmandatory_in;
  }
  
  transition(I, allocI_store, I_store) {
      allocEntry;
      allocPopulateTBE;
  actionI_I_store;
      popmandatory_in;
  }
  
  transition(M, MloadMEvent, M) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      popmandatory_in;
  }
  
  transition(O, OloadOEvent, O) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      popmandatory_in;
  }
  
  transition(S, SloadSEvent, S) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      popmandatory_in;
  }
  
  transition(M, MstoreMEvent, M) {
      writePartialLocal; // Unlike in an L1Cache, the controller must handle actually writing the value
      storeHit;  // In DMA, no difference in callback for local/remote hits
      popmandatory_in;
  }
  
  transition(M, externalloadMfwdfrom_in, M) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      popfwdfrom_in;
  }
  
  transition(O, externalloadOfwdfrom_in, O) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      popfwdfrom_in;
  }
  
  transition(S, externalloadSfwdfrom_in, S) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      popfwdfrom_in;
  }
  
  transition(M, externalstoreMfwdfrom_in, M) {
      writePartial; // Unlike in an L1Cache, the controller must handle actually writing the value
      storeHit;  // In DMA, no difference in callback for local/remote hits
      deallocTBE;
      popfwdfrom_in;
  }
  
  transition(M, externalloadMreqfrom_in, M) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      popreqfrom_in;
  }
  
  transition(O, externalloadOreqfrom_in, O) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      popreqfrom_in;
  }
  
  transition(S, externalloadSreqfrom_in, S) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      popreqfrom_in;
  }
  
  transition(M, externalstoreMreqfrom_in, M) {
      writePartial; // Unlike in an L1Cache, the controller must handle actually writing the value
      storeHit;  // In DMA, no difference in callback for local/remote hits
      deallocTBE;
      popreqfrom_in;
  }
  
  transition(M, externalloadMrespfrom_in, M) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      poprespfrom_in;
  }
  
  transition(O, externalloadOrespfrom_in, O) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      poprespfrom_in;
  }
  
  transition(S, externalloadSrespfrom_in, S) {
      loadHit;  // In DMA, no difference in callback for local/remote hits
      poprespfrom_in;
  }
  
  transition(M, externalstoreMrespfrom_in, M) {
      writePartial; // Unlike in an L1Cache, the controller must handle actually writing the value
      storeHit;  // In DMA, no difference in callback for local/remote hits
      deallocTBE;
      poprespfrom_in;
  }
  
  transition({I, I_load, I_store, I_store_GetM_Ack_AD, I_x_M_evict, I_x_O_evict, I_x_S_evict, M, M_evict, O, O_evict, O_store, O_store_GetM_Ack_AD, S, S_evict, S_store, S_store_GetM_Ack_AD}, Stall) {
      stall;
  }
}
// EOF<DMA>
