//SLICC.ModularSLICC.dir.GenDirHeader
machine(MachineType:Directory, "Directory protocol")
:

  DirectoryMemory *directory;
  // The following latencies should be exposed as command-line parameters in a future update
  Cycles toMemLatency := 1;
  Cycles responseLatency := 6;
  Cycles recycleLatency := 10;

  // Required networks
  MessageBuffer *requestToMemory;
  MessageBuffer *responseFromMemory;

  // Dynamic networks
  MessageBuffer *datTo, network="From", virtual_network="0", vnet_type="dat";
  MessageBuffer *datFrom, network="To", virtual_network="0", vnet_type="dat";
  MessageBuffer *rspTo, network="From", virtual_network="1", vnet_type="rsp";
  MessageBuffer *rspFrom, network="To", virtual_network="1", vnet_type="rsp";
  MessageBuffer *snpTo, network="From", virtual_network="2", vnet_type="snp";
  MessageBuffer *snpFrom, network="To", virtual_network="2", vnet_type="snp";
  MessageBuffer *reqTo, network="From", virtual_network="3", vnet_type="req";
  MessageBuffer *reqFrom, network="To", virtual_network="3", vnet_type="req";

{
  //SLICC.ModularSLICC.dir.GenDirStateDecl
  state_declaration(State, desc="Directory states", default="Directory_State_I") {
      E, AccessPermission:Maybe_Stale, desc="... TODO ...";
      E_ReadShared, AccessPermission:Busy, desc="... TODO ...";
      E_ReadShared_SnpResp_O_Fwded_S, AccessPermission:Busy, desc="... TODO ...";
      E_ReadShared_SnpResp_S_Fwded_S, AccessPermission:Busy, desc="... TODO ...";
      E_ReadUnique, AccessPermission:Busy, desc="... TODO ...";
      E_ReadUnique_SnpResp_I_Fwded_M_PD, AccessPermission:Busy, desc="... TODO ...";
      E_WriteBackFull, AccessPermission:Busy, desc="... TODO ...";
      I, AccessPermission:Read_Write, desc="... TODO ...";
      I_ReadShared, AccessPermission:Busy, desc="... TODO ...";
      I_ReadUnique, AccessPermission:Busy, desc="... TODO ...";
      I_WriteBackFull, AccessPermission:Busy, desc="... TODO ...";
      M, AccessPermission:Maybe_Stale, desc="... TODO ...";
      M_ReadShared, AccessPermission:Busy, desc="... TODO ...";
      M_ReadShared_SnpResp_O_Fwded_S, AccessPermission:Busy, desc="... TODO ...";
      M_ReadUnique, AccessPermission:Busy, desc="... TODO ...";
      M_ReadUnique_SnpResp_I_Fwded_M_PD, AccessPermission:Busy, desc="... TODO ...";
      M_WriteBackFull, AccessPermission:Busy, desc="... TODO ...";
      O, AccessPermission:Maybe_Stale, desc="... TODO ...";
      O_ReadShared, AccessPermission:Busy, desc="... TODO ...";
      O_ReadShared_SnpResp_O_Fwded_S, AccessPermission:Busy, desc="... TODO ...";
      O_ReadUnique, AccessPermission:Busy, desc="... TODO ...";
      O_ReadUnique_SnpRespData_I_PD, AccessPermission:Busy, desc="... TODO ...";
      O_ReadUnique_SnpResp_I, AccessPermission:Busy, desc="... TODO ...";
      O_WriteBackFull, AccessPermission:Busy, desc="... TODO ...";
      S, AccessPermission:Maybe_Stale, desc="... TODO ...";
      S_ReadShared, AccessPermission:Busy, desc="... TODO ...";
      S_ReadUnique, AccessPermission:Busy, desc="... TODO ...";
      S_ReadUnique_SnpResp_I, AccessPermission:Busy, desc="... TODO ...";
      S_WriteBackFull, AccessPermission:Busy, desc="... TODO ...";
    E_WriteBackFull_CBWR_Data_M_PDL1C1_0, AccessPermission:Busy, desc="... TODO ...";
    I_ReadSharedL1C1_0, AccessPermission:Busy, desc="... TODO ...";
    I_ReadUniqueL1C1_0, AccessPermission:Busy, desc="... TODO ...";
    M_WriteBackFull_CBWR_Data_M_PDL1C1_0, AccessPermission:Busy, desc="... TODO ...";
    O_ReadUnique_SnpRespData_I_PDL1C1_0, AccessPermission:Busy, desc="... TODO ...";
    O_ReadUnique_SnpResp_IL1C1_0, AccessPermission:Busy, desc="... TODO ...";
    O_WriteBackFull_CBWR_Data_O_PDL1C1_0, AccessPermission:Busy, desc="... TODO ...";
    O_WriteBackFull_CBWR_Data_O_PDL1C1_1, AccessPermission:Busy, desc="... TODO ...";
    S_ReadSharedL1C1_0, AccessPermission:Busy, desc="... TODO ...";
    S_ReadUniqueL1C1_0, AccessPermission:Busy, desc="... TODO ...";
    S_ReadUniqueL1C1_1, AccessPermission:Busy, desc="... TODO ...";
    S_ReadUnique_SnpResp_IL1C1_0, AccessPermission:Busy, desc="... TODO ...";
  }
  
  //SLICC.ModularSLICC.dir.GenDirEvents
  enumeration(Event, desc="Directory events") {
    StallmemQueue_in, desc="Stall the memQueue_in port.";
    
    Stalldatto_in, desc="Stall the datto_in port.";
    
    Stallreqto_in, desc="Stall the reqto_in port.";
    
    Stallrspto_in, desc="Stall the rspto_in port.";
    
    Stallsnpto_in, desc="Stall the snpto_in port.";
    
    allocTBE, desc="Allocate a new TBE.";
    
    deallocTBE, desc="Deallocate a TBE.";
    
    Progress, desc="Progress, please!";
  }
  
  //SLICC.ModularSLICC.dir.GenDirStruct
  structure(Entry, desc="Stored variables of the Directory machine", interface="AbstractCacheEntry", main="false") {
    State DirectoryState, desc="Directory state";
    DataBlock cl, desc="... TODO ...";
    int acksReceivedL1C1, default=0, desc="...TODO...";
    int acksExpectedL1C1, default=0, desc="...TODO...";
    NetDest cacheL1C1, desc="... TODO ...";
    MachineID ownerL1C1, desc="... TODO ...";
  }
  
  //SLICC.ModularSLICC.dir.GenDirTBE
  structure(TBE, desc="TBE entries for Directory machine") {
    State TBEState,       desc="Transient State";
  
  }
  
  structure(TBETable, external="yes"){
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
    bool areNSlotsAvailable(int, Tick);
  }
  
  TBETable TBEs, template="<Directory_TBE>", constructor="m_number_of_TBEs";
  
  
  //SLICC.ModularSLICC.dir.GenDirStaticFns
  Tick clockEdge();
  Tick cyclesToTicks(Cycles c);
  Cycles ticksToCycles(Tick t);
  void set_tbe(TBE a);
  void unset_tbe();
  
  Entry getEntry(Addr LineAddress), return_by_pointer="yes" {
    Entry entry := static_cast(Entry, "pointer", directory[LineAddress]);
    if (is_invalid(entry)) {
      entry := static_cast(Entry, "pointer", directory.allocate(LineAddress, new Entry));
    }
    return entry;
  }
  
  State getState(TBE tbe, Addr LineAddress) {
    if (is_valid(tbe)) {
      return tbe.TBEState;
    } else if (directory.isPresent(LineAddress)) {
      return getEntry(LineAddress).DirectoryState;
    } else {
      return State:I;
    }
  }
  
  void setState(TBE tbe, Addr LineAddress, State state) {
    if (is_valid(tbe)) {
      tbe.TBEState := state;
    }
    if (directory.isPresent(LineAddress)) {
      getEntry(LineAddress).DirectoryState := state;
    }
  }
  
  AccessPermission getAccessPermission(Addr LineAddress) {
    TBE tbe := TBEs[LineAddress];
    if (is_valid(tbe)) {
      return Directory_State_to_permission(tbe.TBEState);
    } else if (directory.isPresent(LineAddress)) {
      return Directory_State_to_permission(getEntry(LineAddress).DirectoryState);
    } else {
      return AccessPermission:NotPresent;
    }
  }
  
  void setAccessPermission(Addr LineAddress, State state) {
    if (directory.isPresent(LineAddress)) {
      getEntry(LineAddress).changePermission(Directory_State_to_permission(state));
    }
  }
  
  void functionalRead(Addr LineAddress, Packet *pkt) {
    functionalMemoryRead(pkt);
  }
  
  int functionalWrite(Addr LineAddress, Packet *pkt) {
    return 0 + functionalMemoryWrite(pkt);
  }
  
  //SLICC.ModularSLICC.dir.GenDirOutPorts
  out_port(memQueue_out, MemoryMsg, requestToMemory);
  out_port(datfrom_out, CoherenceMessage, datFrom);
  out_port(reqfrom_out, CoherenceMessage, reqFrom);
  out_port(rspfrom_out, CoherenceMessage, rspFrom);
  out_port(snpfrom_out, CoherenceMessage, snpFrom);
  
  //SLICC.ModularSLICC.dir.GenDirInPorts
  in_port(memQueue_in, MemoryMsg, responseFromMemory) {
    if (memQueue_in.isReady(clockEdge())) {
      peek(memQueue_in, MemoryMsg) {
        Addr LineAddress := in_msg.addr;
        TBE tbe := TBEs[LineAddress];
        State st := getState(tbe, LineAddress);
        if (st == State:E_WriteBackFull_CBWR_Data_M_PDL1C1_0 
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          
          setState(tbe, LineAddress, State:I);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else if (st == State:I_ReadSharedL1C1_0 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          enqueue(datfrom_out, CoherenceMessage, responseLatency) {
            out_msg.LineAddress := LineAddress;
            out_msg.MessageSize := MessageSizeType:Data;
            out_msg.Destination.add(in_msg.OriginalRequestorMachId);
            out_msg.Type := CoherenceMessageType:CompData_EL1C1;
            out_msg.Sender := machineID;
            out_msg.cl := in_msg.DataBlk;
          }
          getEntry(LineAddress).ownerL1C1 := in_msg.OriginalRequestorMachId;
          setState(tbe, LineAddress, State:I_ReadShared);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else if (st == State:I_ReadUniqueL1C1_0 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          enqueue(datfrom_out, CoherenceMessage, responseLatency) {
            out_msg.LineAddress := LineAddress;
            out_msg.MessageSize := MessageSizeType:Data;
            out_msg.Destination.add(in_msg.OriginalRequestorMachId);
            out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
            out_msg.Sender := machineID;
            out_msg.cl := in_msg.DataBlk;
          }
          getEntry(LineAddress).ownerL1C1 := in_msg.OriginalRequestorMachId;
          setState(tbe, LineAddress, State:I_ReadUnique);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else if (st == State:M_WriteBackFull_CBWR_Data_M_PDL1C1_0 
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          
          setState(tbe, LineAddress, State:I);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else if (st == State:O_ReadUnique_SnpRespData_I_PDL1C1_0 
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          
          setState(tbe, LineAddress, State:O_ReadUnique);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else if (st == State:O_ReadUnique_SnpResp_IL1C1_0 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          enqueue(datfrom_out, CoherenceMessage, responseLatency) {
            out_msg.LineAddress := LineAddress;
            out_msg.MessageSize := MessageSizeType:Data;
            out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
            out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
            out_msg.Sender := machineID;
            out_msg.cl := in_msg.DataBlk;
          }
          setState(tbe, LineAddress, State:O_ReadUnique_SnpResp_I);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else if (st == State:O_WriteBackFull_CBWR_Data_O_PDL1C1_0 
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          
          setState(tbe, LineAddress, State:I);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else if (st == State:O_WriteBackFull_CBWR_Data_O_PDL1C1_1 
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          
          setState(tbe, LineAddress, State:S);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else if (st == State:S_ReadSharedL1C1_0 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          enqueue(datfrom_out, CoherenceMessage, responseLatency) {
            out_msg.LineAddress := LineAddress;
            out_msg.MessageSize := MessageSizeType:Data;
            out_msg.Destination.add(in_msg.OriginalRequestorMachId);
            out_msg.Type := CoherenceMessageType:CompData_SL1C1;
            out_msg.Sender := machineID;
            out_msg.cl := in_msg.DataBlk;
          }
          getEntry(LineAddress).cacheL1C1.add(in_msg.OriginalRequestorMachId);
          setState(tbe, LineAddress, State:S_ReadShared);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else if (st == State:S_ReadUniqueL1C1_0 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          enqueue(datfrom_out, CoherenceMessage, responseLatency) {
            out_msg.LineAddress := LineAddress;
            out_msg.MessageSize := MessageSizeType:Data;
            out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
            out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
            out_msg.Sender := machineID;
            out_msg.cl := in_msg.DataBlk;
          }
          setState(tbe, LineAddress, State:S_ReadUnique);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else if (st == State:S_ReadUniqueL1C1_1 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          enqueue(datfrom_out, CoherenceMessage, responseLatency) {
            out_msg.LineAddress := LineAddress;
            out_msg.MessageSize := MessageSizeType:Data;
            out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
            out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
            out_msg.Sender := machineID;
            out_msg.cl := in_msg.DataBlk;
          }
          setState(tbe, LineAddress, State:S_ReadUnique);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else if (st == State:S_ReadUnique_SnpResp_IL1C1_0 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          enqueue(datfrom_out, CoherenceMessage, responseLatency) {
            out_msg.LineAddress := LineAddress;
            out_msg.MessageSize := MessageSizeType:Data;
            out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
            out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
            out_msg.Sender := machineID;
            out_msg.cl := in_msg.DataBlk;
          }
          setState(tbe, LineAddress, State:S_ReadUnique_SnpResp_I);
          
          memQueue_in.dequeue(clockEdge());
          trigger(Event:deallocTBE, LineAddress, tbe);
        } else {
          trigger(Event:StallmemQueue_in, LineAddress, tbe);}
      }
    }
  }
  
  in_port(datto_in, CoherenceMessage, datTo) {
    if (datto_in.isReady(clockEdge())) {
      peek (datto_in, CoherenceMessage, block_on="LineAddress") {
        Addr LineAddress := in_msg.LineAddress;
        TBE tbe := TBEs[LineAddress];
        State st := getState(tbe, LineAddress);
        if (st == State:E) {
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (in_msg.Sender != getEntry(LineAddress).ownerL1C1) {
              setState(tbe, LineAddress, State:E);
              datto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (in_msg.Sender == getEntry(LineAddress).ownerL1C1) {
              setState(tbe, LineAddress, State:I);
              datto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(getEntry(LineAddress).ownerL1C1);
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:E_ReadShared);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpUniqueFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            setState(tbe, LineAddress, State:E_ReadUnique);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:E_WriteBackFull);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:E_ReadShared_SnpResp_O_Fwded_S);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_S_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:E_ReadShared_SnpResp_S_Fwded_S);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared_SnpResp_S_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:S);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_I_Fwded_M_PDL1C1) {
            setState(tbe, LineAddress, State:E_ReadUnique_SnpResp_I_Fwded_M_PD);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadUnique_SnpResp_I_Fwded_M_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:E_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:E);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_M_PDL1C1) {
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_WB;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Writeback_Data;
              out_msg.DataBlk := in_msg.cl;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:E_WriteBackFull_CBWR_Data_M_PDL1C1_0);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:I) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:I);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:I_ReadSharedL1C1_0);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:I_ReadUniqueL1C1_0);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:I_WriteBackFull);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:I_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:E);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:I_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:I_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:I);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:M) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:M);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(getEntry(LineAddress).ownerL1C1);
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:M_ReadShared);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpUniqueFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            setState(tbe, LineAddress, State:M_ReadUnique);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:M_WriteBackFull);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:M_ReadShared_SnpResp_O_Fwded_S);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_I_Fwded_M_PDL1C1) {
            setState(tbe, LineAddress, State:M_ReadUnique_SnpResp_I_Fwded_M_PD);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadUnique_SnpResp_I_Fwded_M_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:M_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:M);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_M_PDL1C1) {
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_WB;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Writeback_Data;
              out_msg.DataBlk := in_msg.cl;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:M_WriteBackFull_CBWR_Data_M_PDL1C1_0);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:O) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              setState(tbe, LineAddress, State:O);
              datto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              if (getEntry(LineAddress).cacheL1C1.count() != 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:O);
                datto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).cacheL1C1.count() == 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:I);
                datto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:O_ReadShared);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).cacheL1C1.count();
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).acksExpectedL1C1-1;
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              getEntry(LineAddress).acksReceivedL1C1 := 0;
              getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
              if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                  out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, LineAddress, State:O_ReadUnique);
                datto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:O_ReadUnique);
                datto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).acksReceivedL1C1 := 0;
              getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
              if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                  out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, LineAddress, State:O_ReadUnique);
                datto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:O_ReadUnique);
                datto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:O_WriteBackFull);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:O_ReadShared_SnpResp_O_Fwded_S);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpRespData_I_PDL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpRespData_I_PDL1C1_0);
              datto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(datfrom_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                out_msg.Sender := machineID;
                out_msg.cl := in_msg.cl;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpRespData_I_PD);
              datto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_IL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_READ;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Request_Control;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpResp_IL1C1_0);
              datto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              setState(tbe, LineAddress, State:O_ReadUnique);
              datto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique_SnpRespData_I_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique_SnpResp_I) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:O_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:O);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_O_PDL1C1) {
            if (getEntry(LineAddress).cacheL1C1.count() == 1) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_WriteBackFull_CBWR_Data_O_PDL1C1_0);
              datto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.count() != 1) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_WriteBackFull_CBWR_Data_O_PDL1C1_1);
              datto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:S) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              setState(tbe, LineAddress, State:S);
              datto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              if (getEntry(LineAddress).cacheL1C1.count() == 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:I);
                datto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).cacheL1C1.count() != 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:S);
                datto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:S_ReadSharedL1C1_0);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).cacheL1C1.count();
            getEntry(LineAddress).acksReceivedL1C1 := 0;
            if (getEntry(LineAddress).cacheL1C1.isElement(getEntry(LineAddress).ownerL1C1)) {
              getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).acksExpectedL1C1-1;
              getEntry(LineAddress).cacheL1C1.remove(getEntry(LineAddress).ownerL1C1);
              if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:S_ReadUnique);
                datto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                  out_msg.addr := LineAddress;
                  out_msg.Type := MemoryRequestType:MEMORY_READ;
                  out_msg.Sender := in_msg.Sender;
                  out_msg.MessageSize := MessageSizeType:Request_Control;
                  out_msg.Len := 0;
                }
                setState(tbe, LineAddress, State:S_ReadUniqueL1C1_0);
                datto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(getEntry(LineAddress).ownerL1C1) == false) {
              if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:S_ReadUnique);
                datto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                  out_msg.addr := LineAddress;
                  out_msg.Type := MemoryRequestType:MEMORY_READ;
                  out_msg.Sender := in_msg.Sender;
                  out_msg.MessageSize := MessageSizeType:Request_Control;
                  out_msg.Len := 0;
                }
                setState(tbe, LineAddress, State:S_ReadUniqueL1C1_1);
                datto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stalldatto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:S_WriteBackFull);
            datto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:S);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_IL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              setState(tbe, LineAddress, State:S_ReadUnique);
              datto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_READ;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Request_Control;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:S_ReadUnique_SnpResp_IL1C1_0);
              datto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadUnique_SnpResp_I) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else if (st == State:S_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:S);
            datto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stalldatto_in, LineAddress, tbe);
          }
        } else {
          trigger(Event:Stalldatto_in, LineAddress, tbe);
        }
      }
    }
  }
  
  in_port(rspto_in, CoherenceMessage, rspTo) {
    if (rspto_in.isReady(clockEdge())) {
      peek (rspto_in, CoherenceMessage, block_on="LineAddress") {
        Addr LineAddress := in_msg.LineAddress;
        TBE tbe := TBEs[LineAddress];
        State st := getState(tbe, LineAddress);
        if (st == State:E) {
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (in_msg.Sender != getEntry(LineAddress).ownerL1C1) {
              setState(tbe, LineAddress, State:E);
              rspto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (in_msg.Sender == getEntry(LineAddress).ownerL1C1) {
              setState(tbe, LineAddress, State:I);
              rspto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(getEntry(LineAddress).ownerL1C1);
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:E_ReadShared);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpUniqueFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            setState(tbe, LineAddress, State:E_ReadUnique);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:E_WriteBackFull);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:E_ReadShared_SnpResp_O_Fwded_S);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_S_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:E_ReadShared_SnpResp_S_Fwded_S);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared_SnpResp_S_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:S);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_I_Fwded_M_PDL1C1) {
            setState(tbe, LineAddress, State:E_ReadUnique_SnpResp_I_Fwded_M_PD);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadUnique_SnpResp_I_Fwded_M_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:E_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:E);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_M_PDL1C1) {
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_WB;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Writeback_Data;
              out_msg.DataBlk := in_msg.cl;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:E_WriteBackFull_CBWR_Data_M_PDL1C1_0);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:I) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:I);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:I_ReadSharedL1C1_0);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:I_ReadUniqueL1C1_0);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:I_WriteBackFull);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:I_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:E);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:I_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:I_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:I);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:M) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:M);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(getEntry(LineAddress).ownerL1C1);
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:M_ReadShared);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpUniqueFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            setState(tbe, LineAddress, State:M_ReadUnique);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:M_WriteBackFull);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:M_ReadShared_SnpResp_O_Fwded_S);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_I_Fwded_M_PDL1C1) {
            setState(tbe, LineAddress, State:M_ReadUnique_SnpResp_I_Fwded_M_PD);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadUnique_SnpResp_I_Fwded_M_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:M_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:M);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_M_PDL1C1) {
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_WB;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Writeback_Data;
              out_msg.DataBlk := in_msg.cl;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:M_WriteBackFull_CBWR_Data_M_PDL1C1_0);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:O) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              setState(tbe, LineAddress, State:O);
              rspto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              if (getEntry(LineAddress).cacheL1C1.count() != 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:O);
                rspto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).cacheL1C1.count() == 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:I);
                rspto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:O_ReadShared);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).cacheL1C1.count();
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).acksExpectedL1C1-1;
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              getEntry(LineAddress).acksReceivedL1C1 := 0;
              getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
              if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                  out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, LineAddress, State:O_ReadUnique);
                rspto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:O_ReadUnique);
                rspto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).acksReceivedL1C1 := 0;
              getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
              if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                  out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, LineAddress, State:O_ReadUnique);
                rspto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:O_ReadUnique);
                rspto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:O_WriteBackFull);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:O_ReadShared_SnpResp_O_Fwded_S);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpRespData_I_PDL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpRespData_I_PDL1C1_0);
              rspto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(datfrom_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                out_msg.Sender := machineID;
                out_msg.cl := in_msg.cl;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpRespData_I_PD);
              rspto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_IL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_READ;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Request_Control;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpResp_IL1C1_0);
              rspto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              setState(tbe, LineAddress, State:O_ReadUnique);
              rspto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique_SnpRespData_I_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique_SnpResp_I) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:O_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:O);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_O_PDL1C1) {
            if (getEntry(LineAddress).cacheL1C1.count() == 1) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_WriteBackFull_CBWR_Data_O_PDL1C1_0);
              rspto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.count() != 1) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_WriteBackFull_CBWR_Data_O_PDL1C1_1);
              rspto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:S) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              setState(tbe, LineAddress, State:S);
              rspto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              if (getEntry(LineAddress).cacheL1C1.count() == 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:I);
                rspto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).cacheL1C1.count() != 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:S);
                rspto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:S_ReadSharedL1C1_0);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).cacheL1C1.count();
            getEntry(LineAddress).acksReceivedL1C1 := 0;
            if (getEntry(LineAddress).cacheL1C1.isElement(getEntry(LineAddress).ownerL1C1)) {
              getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).acksExpectedL1C1-1;
              getEntry(LineAddress).cacheL1C1.remove(getEntry(LineAddress).ownerL1C1);
              if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:S_ReadUnique);
                rspto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                  out_msg.addr := LineAddress;
                  out_msg.Type := MemoryRequestType:MEMORY_READ;
                  out_msg.Sender := in_msg.Sender;
                  out_msg.MessageSize := MessageSizeType:Request_Control;
                  out_msg.Len := 0;
                }
                setState(tbe, LineAddress, State:S_ReadUniqueL1C1_0);
                rspto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(getEntry(LineAddress).ownerL1C1) == false) {
              if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:S_ReadUnique);
                rspto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                  out_msg.addr := LineAddress;
                  out_msg.Type := MemoryRequestType:MEMORY_READ;
                  out_msg.Sender := in_msg.Sender;
                  out_msg.MessageSize := MessageSizeType:Request_Control;
                  out_msg.Len := 0;
                }
                setState(tbe, LineAddress, State:S_ReadUniqueL1C1_1);
                rspto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallrspto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:S_WriteBackFull);
            rspto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:S);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_IL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              setState(tbe, LineAddress, State:S_ReadUnique);
              rspto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_READ;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Request_Control;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:S_ReadUnique_SnpResp_IL1C1_0);
              rspto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadUnique_SnpResp_I) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else if (st == State:S_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:S);
            rspto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallrspto_in, LineAddress, tbe);
          }
        } else {
          trigger(Event:Stallrspto_in, LineAddress, tbe);
        }
      }
    }
  }
  
  in_port(snpto_in, CoherenceMessage, snpTo) {
    if (snpto_in.isReady(clockEdge())) {
      peek (snpto_in, CoherenceMessage, block_on="LineAddress") {
        Addr LineAddress := in_msg.LineAddress;
        TBE tbe := TBEs[LineAddress];
        State st := getState(tbe, LineAddress);
        if (st == State:E) {
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (in_msg.Sender != getEntry(LineAddress).ownerL1C1) {
              setState(tbe, LineAddress, State:E);
              snpto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (in_msg.Sender == getEntry(LineAddress).ownerL1C1) {
              setState(tbe, LineAddress, State:I);
              snpto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(getEntry(LineAddress).ownerL1C1);
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:E_ReadShared);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpUniqueFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            setState(tbe, LineAddress, State:E_ReadUnique);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:E_WriteBackFull);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:E_ReadShared_SnpResp_O_Fwded_S);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_S_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:E_ReadShared_SnpResp_S_Fwded_S);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared_SnpResp_S_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:S);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_I_Fwded_M_PDL1C1) {
            setState(tbe, LineAddress, State:E_ReadUnique_SnpResp_I_Fwded_M_PD);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadUnique_SnpResp_I_Fwded_M_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:E_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:E);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_M_PDL1C1) {
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_WB;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Writeback_Data;
              out_msg.DataBlk := in_msg.cl;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:E_WriteBackFull_CBWR_Data_M_PDL1C1_0);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:I) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:I);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:I_ReadSharedL1C1_0);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:I_ReadUniqueL1C1_0);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:I_WriteBackFull);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:I_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:E);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:I_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:I_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:I);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:M) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:M);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(getEntry(LineAddress).ownerL1C1);
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:M_ReadShared);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpUniqueFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            setState(tbe, LineAddress, State:M_ReadUnique);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:M_WriteBackFull);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:M_ReadShared_SnpResp_O_Fwded_S);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_I_Fwded_M_PDL1C1) {
            setState(tbe, LineAddress, State:M_ReadUnique_SnpResp_I_Fwded_M_PD);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadUnique_SnpResp_I_Fwded_M_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:M_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:M);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_M_PDL1C1) {
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_WB;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Writeback_Data;
              out_msg.DataBlk := in_msg.cl;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:M_WriteBackFull_CBWR_Data_M_PDL1C1_0);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:O) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              setState(tbe, LineAddress, State:O);
              snpto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              if (getEntry(LineAddress).cacheL1C1.count() != 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:O);
                snpto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).cacheL1C1.count() == 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:I);
                snpto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:O_ReadShared);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).cacheL1C1.count();
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).acksExpectedL1C1-1;
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              getEntry(LineAddress).acksReceivedL1C1 := 0;
              getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
              if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                  out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, LineAddress, State:O_ReadUnique);
                snpto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:O_ReadUnique);
                snpto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).acksReceivedL1C1 := 0;
              getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
              if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                  out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, LineAddress, State:O_ReadUnique);
                snpto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:O_ReadUnique);
                snpto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:O_WriteBackFull);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:O_ReadShared_SnpResp_O_Fwded_S);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpRespData_I_PDL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpRespData_I_PDL1C1_0);
              snpto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(datfrom_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                out_msg.Sender := machineID;
                out_msg.cl := in_msg.cl;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpRespData_I_PD);
              snpto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_IL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_READ;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Request_Control;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpResp_IL1C1_0);
              snpto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              setState(tbe, LineAddress, State:O_ReadUnique);
              snpto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique_SnpRespData_I_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique_SnpResp_I) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:O_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:O);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_O_PDL1C1) {
            if (getEntry(LineAddress).cacheL1C1.count() == 1) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_WriteBackFull_CBWR_Data_O_PDL1C1_0);
              snpto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.count() != 1) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_WriteBackFull_CBWR_Data_O_PDL1C1_1);
              snpto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:S) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              setState(tbe, LineAddress, State:S);
              snpto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              if (getEntry(LineAddress).cacheL1C1.count() == 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:I);
                snpto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).cacheL1C1.count() != 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:S);
                snpto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:S_ReadSharedL1C1_0);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).cacheL1C1.count();
            getEntry(LineAddress).acksReceivedL1C1 := 0;
            if (getEntry(LineAddress).cacheL1C1.isElement(getEntry(LineAddress).ownerL1C1)) {
              getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).acksExpectedL1C1-1;
              getEntry(LineAddress).cacheL1C1.remove(getEntry(LineAddress).ownerL1C1);
              if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:S_ReadUnique);
                snpto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                  out_msg.addr := LineAddress;
                  out_msg.Type := MemoryRequestType:MEMORY_READ;
                  out_msg.Sender := in_msg.Sender;
                  out_msg.MessageSize := MessageSizeType:Request_Control;
                  out_msg.Len := 0;
                }
                setState(tbe, LineAddress, State:S_ReadUniqueL1C1_0);
                snpto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(getEntry(LineAddress).ownerL1C1) == false) {
              if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:S_ReadUnique);
                snpto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                  out_msg.addr := LineAddress;
                  out_msg.Type := MemoryRequestType:MEMORY_READ;
                  out_msg.Sender := in_msg.Sender;
                  out_msg.MessageSize := MessageSizeType:Request_Control;
                  out_msg.Len := 0;
                }
                setState(tbe, LineAddress, State:S_ReadUniqueL1C1_1);
                snpto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallsnpto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:S_WriteBackFull);
            snpto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:S);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_IL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              setState(tbe, LineAddress, State:S_ReadUnique);
              snpto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_READ;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Request_Control;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:S_ReadUnique_SnpResp_IL1C1_0);
              snpto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadUnique_SnpResp_I) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else if (st == State:S_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:S);
            snpto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallsnpto_in, LineAddress, tbe);
          }
        } else {
          trigger(Event:Stallsnpto_in, LineAddress, tbe);
        }
      }
    }
  }
  
  in_port(reqto_in, CoherenceMessage, reqTo) {
    if (reqto_in.isReady(clockEdge())) {
      peek (reqto_in, CoherenceMessage, block_on="LineAddress") {
        Addr LineAddress := in_msg.LineAddress;
        TBE tbe := TBEs[LineAddress];
        State st := getState(tbe, LineAddress);
        if (st == State:E) {
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (in_msg.Sender != getEntry(LineAddress).ownerL1C1) {
              setState(tbe, LineAddress, State:E);
              reqto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (in_msg.Sender == getEntry(LineAddress).ownerL1C1) {
              setState(tbe, LineAddress, State:I);
              reqto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(getEntry(LineAddress).ownerL1C1);
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:E_ReadShared);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpUniqueFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            setState(tbe, LineAddress, State:E_ReadUnique);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:E_WriteBackFull);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:E_ReadShared_SnpResp_O_Fwded_S);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_S_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:E_ReadShared_SnpResp_S_Fwded_S);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadShared_SnpResp_S_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:S);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_I_Fwded_M_PDL1C1) {
            setState(tbe, LineAddress, State:E_ReadUnique_SnpResp_I_Fwded_M_PD);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:E_ReadUnique_SnpResp_I_Fwded_M_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:E_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:E);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_M_PDL1C1) {
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_WB;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Writeback_Data;
              out_msg.DataBlk := in_msg.cl;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:E_WriteBackFull_CBWR_Data_M_PDL1C1_0);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:I) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:I);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:I_ReadSharedL1C1_0);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:I_ReadUniqueL1C1_0);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:I_WriteBackFull);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:I_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:E);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:I_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:I_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:I);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:M) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:M);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(getEntry(LineAddress).ownerL1C1);
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:M_ReadShared);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpUniqueFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            setState(tbe, LineAddress, State:M_ReadUnique);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:M_WriteBackFull);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:M_ReadShared_SnpResp_O_Fwded_S);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_I_Fwded_M_PDL1C1) {
            setState(tbe, LineAddress, State:M_ReadUnique_SnpResp_I_Fwded_M_PD);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:M_ReadUnique_SnpResp_I_Fwded_M_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:M);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:M_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:M);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_M_PDL1C1) {
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_WB;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Writeback_Data;
              out_msg.DataBlk := in_msg.cl;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:M_WriteBackFull_CBWR_Data_M_PDL1C1_0);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:O) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              setState(tbe, LineAddress, State:O);
              reqto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              if (getEntry(LineAddress).cacheL1C1.count() != 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:O);
                reqto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).cacheL1C1.count() == 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:I);
                reqto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
              out_msg.Type := CoherenceMessageType:SnpSharedFwdL1C1;
              out_msg.Sender := in_msg.Sender;
            }
            getEntry(LineAddress).cacheL1C1.add(in_msg.Sender);
            setState(tbe, LineAddress, State:O_ReadShared);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).cacheL1C1.count();
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).acksExpectedL1C1-1;
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              getEntry(LineAddress).acksReceivedL1C1 := 0;
              getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
              if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                  out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, LineAddress, State:O_ReadUnique);
                reqto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:O_ReadUnique);
                reqto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).acksReceivedL1C1 := 0;
              getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
              if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                  out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                  out_msg.Sender := machineID;
                }
                setState(tbe, LineAddress, State:O_ReadUnique);
                reqto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:O_ReadUnique);
                reqto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:O_WriteBackFull);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:SnpResp_O_Fwded_SL1C1) {
            setState(tbe, LineAddress, State:O_ReadShared_SnpResp_O_Fwded_S);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadShared_SnpResp_O_Fwded_S) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:O);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpRespData_I_PDL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpRespData_I_PDL1C1_0);
              reqto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(datfrom_out, CoherenceMessage, responseLatency) {
                out_msg.LineAddress := LineAddress;
                out_msg.MessageSize := MessageSizeType:Data;
                out_msg.Destination.add(getEntry(LineAddress).ownerL1C1);
                out_msg.Type := CoherenceMessageType:CompData_M_PDL1C1;
                out_msg.Sender := machineID;
                out_msg.cl := in_msg.cl;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpRespData_I_PD);
              reqto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_IL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_READ;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Request_Control;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_ReadUnique_SnpResp_IL1C1_0);
              reqto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              setState(tbe, LineAddress, State:O_ReadUnique);
              reqto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique_SnpRespData_I_PD) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:O_ReadUnique_SnpResp_I) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:O_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:O);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:CBWR_Data_O_PDL1C1) {
            if (getEntry(LineAddress).cacheL1C1.count() == 1) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_WriteBackFull_CBWR_Data_O_PDL1C1_0);
              reqto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.count() != 1) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_WB;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Writeback_Data;
                out_msg.DataBlk := in_msg.cl;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:O_WriteBackFull_CBWR_Data_O_PDL1C1_1);
              reqto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:S) {      
          if (in_msg.Type == CoherenceMessageType:EvictL1C1) {
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Comp_IL1C1;
              out_msg.Sender := machineID;
            }
            if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender) == false) {
              getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
              setState(tbe, LineAddress, State:S);
              reqto_in.dequeue(clockEdge());
              trigger(Event:deallocTBE, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(in_msg.Sender)) {
              if (getEntry(LineAddress).cacheL1C1.count() == 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:I);
                reqto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).cacheL1C1.count() != 1) {
                getEntry(LineAddress).cacheL1C1.remove(in_msg.Sender);
                setState(tbe, LineAddress, State:S);
                reqto_in.dequeue(clockEdge());
                trigger(Event:deallocTBE, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:ReadSharedL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(memQueue_out, MemoryMsg, toMemLatency) {
              out_msg.addr := LineAddress;
              out_msg.Type := MemoryRequestType:MEMORY_READ;
              out_msg.Sender := in_msg.Sender;
              out_msg.MessageSize := MessageSizeType:Request_Control;
              out_msg.Len := 0;
            }
            setState(tbe, LineAddress, State:S_ReadSharedL1C1_0);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:ReadUniqueL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            getEntry(LineAddress).ownerL1C1 := in_msg.Sender;
            getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).cacheL1C1.count();
            getEntry(LineAddress).acksReceivedL1C1 := 0;
            if (getEntry(LineAddress).cacheL1C1.isElement(getEntry(LineAddress).ownerL1C1)) {
              getEntry(LineAddress).acksExpectedL1C1 := getEntry(LineAddress).acksExpectedL1C1-1;
              getEntry(LineAddress).cacheL1C1.remove(getEntry(LineAddress).ownerL1C1);
              if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:S_ReadUnique);
                reqto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                  out_msg.addr := LineAddress;
                  out_msg.Type := MemoryRequestType:MEMORY_READ;
                  out_msg.Sender := in_msg.Sender;
                  out_msg.MessageSize := MessageSizeType:Request_Control;
                  out_msg.Len := 0;
                }
                setState(tbe, LineAddress, State:S_ReadUniqueL1C1_0);
                reqto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }
            else if (getEntry(LineAddress).cacheL1C1.isElement(getEntry(LineAddress).ownerL1C1) == false) {
              if (getEntry(LineAddress).acksExpectedL1C1 != 0) {
                enqueue(snpfrom_out, CoherenceMessage, responseLatency) {
                  out_msg.LineAddress := LineAddress;
                  out_msg.MessageSize := MessageSizeType:Control;
                  out_msg.Destination := getEntry(LineAddress).cacheL1C1;
                  out_msg.Type := CoherenceMessageType:SnpCleanInvalidL1C1;
                  out_msg.Sender := machineID;
                }
                getEntry(LineAddress).cacheL1C1.clear();
                setState(tbe, LineAddress, State:S_ReadUnique);
                reqto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
              else if (getEntry(LineAddress).acksExpectedL1C1 == 0) {
                enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                  out_msg.addr := LineAddress;
                  out_msg.Type := MemoryRequestType:MEMORY_READ;
                  out_msg.Sender := in_msg.Sender;
                  out_msg.MessageSize := MessageSizeType:Request_Control;
                  out_msg.Len := 0;
                }
                setState(tbe, LineAddress, State:S_ReadUniqueL1C1_1);
                reqto_in.dequeue(clockEdge());
                trigger(Event:Progress, LineAddress, tbe);
              }
            }  
          } else if (in_msg.Type == CoherenceMessageType:WriteBackFullL1C1) {
            if (is_invalid(tbe)) {
              if (TBEs.areNSlotsAvailable(1, clockEdge())) {
                trigger(Event:allocTBE, LineAddress, tbe);
              } else {
                trigger(Event:Stallreqto_in, LineAddress, tbe);
              }
            }
            enqueue(rspfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := LineAddress;
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:CompDBIDRespL1C1;
              out_msg.Sender := machineID;
            }
            setState(tbe, LineAddress, State:S_WriteBackFull);
            reqto_in.dequeue(clockEdge());
            trigger(Event:Progress, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadShared) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            setState(tbe, LineAddress, State:S);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadUnique) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);  
          } else if (in_msg.Type == CoherenceMessageType:SnpResp_IL1C1) {
            getEntry(LineAddress).acksReceivedL1C1 := getEntry(LineAddress).acksReceivedL1C1+1;
            if (getEntry(LineAddress).acksReceivedL1C1 != getEntry(LineAddress).acksExpectedL1C1) {
              setState(tbe, LineAddress, State:S_ReadUnique);
              reqto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
            else if (getEntry(LineAddress).acksReceivedL1C1 == getEntry(LineAddress).acksExpectedL1C1) {
              enqueue(memQueue_out, MemoryMsg, toMemLatency) {
                out_msg.addr := LineAddress;
                out_msg.Type := MemoryRequestType:MEMORY_READ;
                out_msg.Sender := in_msg.Sender;
                out_msg.MessageSize := MessageSizeType:Request_Control;
                out_msg.Len := 0;
              }
              setState(tbe, LineAddress, State:S_ReadUnique_SnpResp_IL1C1_0);
              reqto_in.dequeue(clockEdge());
              trigger(Event:Progress, LineAddress, tbe);
            }
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:S_ReadUnique_SnpResp_I) {      
          if (in_msg.Type == CoherenceMessageType:CompAckL1C1) {
            getEntry(LineAddress).cacheL1C1.clear();
            setState(tbe, LineAddress, State:M);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else if (st == State:S_WriteBackFull) {      
          if (in_msg.Type == CoherenceMessageType:CBWR_Data_IL1C1) {
            setState(tbe, LineAddress, State:S);
            reqto_in.dequeue(clockEdge());
            trigger(Event:deallocTBE, LineAddress, tbe);
          } else {
            trigger(Event:Stallreqto_in, LineAddress, tbe);
          }
        } else {
          trigger(Event:Stallreqto_in, LineAddress, tbe);
        }
      }
    }
  }
  
  
  //SLICC.ModularSLICC.dir.GenDirActions
  action(a_allocTBE, "aTBE", desc="Allocate TBE entry.") {
    TBEs.allocate(address);
    set_tbe(TBEs[address]);
  }
  
  action(a_deallocTBE, "dTBE", desc="Deallocate TBE entry.") {
    if (is_valid(tbe)) {
      TBEs.deallocate(address);
      unset_tbe();
    }
  }
  
  action(popmemQueue_in, "pmemQueue_in0", desc="Pop the memQueue_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      memQueue_in.dequeue(clockEdge());
  }
  
  action(recyclememQueue_in, "rmemQueue_in0", desc="Recycle the memQueue_in port") {
    memQueue_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
  }
  
  action(popdatto_in, "pdatto_in0", desc="Pop the datto_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      datto_in.dequeue(clockEdge());
  }
  
  action(recycledatto_in, "rdatto_in0", desc="Recycle the datto_in port") {
    datto_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
  }
  
  action(popreqto_in, "preqto_in0", desc="Pop the reqto_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      reqto_in.dequeue(clockEdge());
  }
  
  action(recyclereqto_in, "rreqto_in0", desc="Recycle the reqto_in port") {
    reqto_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
  }
  
  action(poprspto_in, "prspto_in0", desc="Pop the rspto_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      rspto_in.dequeue(clockEdge());
  }
  
  action(recyclerspto_in, "rrspto_in0", desc="Recycle the rspto_in port") {
    rspto_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
  }
  
  action(popsnpto_in, "psnpto_in0", desc="Pop the snpto_in queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      snpto_in.dequeue(clockEdge());
  }
  
  action(recyclesnpto_in, "rsnpto_in0", desc="Recycle the snpto_in port") {
    snpto_in.recycle(clockEdge(), cyclesToTicks(recycleLatency));
  }
  
  action(empty, "e", desc="Empty action") {
      // empty action; useful as SLICC requires valid transitions
      // to be non-empty, but the actions being invoked can still be empty
      // e.g. to simulate a z-stall
  }
  
  //SLICC.ModularSLICC.dir.GenDirTransitions
  
  
  transition({E, E_ReadShared, E_ReadShared_SnpResp_O_Fwded_S, E_ReadShared_SnpResp_S_Fwded_S, E_ReadUnique, E_ReadUnique_SnpResp_I_Fwded_M_PD, E_WriteBackFull, E_WriteBackFull_CBWR_Data_M_PDL1C1_0, I, I_ReadShared, I_ReadSharedL1C1_0, I_ReadUnique, I_ReadUniqueL1C1_0, I_WriteBackFull, M, M_ReadShared, M_ReadShared_SnpResp_O_Fwded_S, M_ReadUnique, M_ReadUnique_SnpResp_I_Fwded_M_PD, M_WriteBackFull, M_WriteBackFull_CBWR_Data_M_PDL1C1_0, O, O_ReadShared, O_ReadShared_SnpResp_O_Fwded_S, O_ReadUnique, O_ReadUnique_SnpRespData_I_PD, O_ReadUnique_SnpRespData_I_PDL1C1_0, O_ReadUnique_SnpResp_I, O_ReadUnique_SnpResp_IL1C1_0, O_WriteBackFull, O_WriteBackFull_CBWR_Data_O_PDL1C1_0, O_WriteBackFull_CBWR_Data_O_PDL1C1_1, S, S_ReadShared, S_ReadSharedL1C1_0, S_ReadUnique, S_ReadUniqueL1C1_0, S_ReadUniqueL1C1_1, S_ReadUnique_SnpResp_I, S_ReadUnique_SnpResp_IL1C1_0, S_WriteBackFull}, Stalldatto_in) {
      recycledatto_in;
  }
  
  transition({E, E_ReadShared, E_ReadShared_SnpResp_O_Fwded_S, E_ReadShared_SnpResp_S_Fwded_S, E_ReadUnique, E_ReadUnique_SnpResp_I_Fwded_M_PD, E_WriteBackFull, E_WriteBackFull_CBWR_Data_M_PDL1C1_0, I, I_ReadShared, I_ReadSharedL1C1_0, I_ReadUnique, I_ReadUniqueL1C1_0, I_WriteBackFull, M, M_ReadShared, M_ReadShared_SnpResp_O_Fwded_S, M_ReadUnique, M_ReadUnique_SnpResp_I_Fwded_M_PD, M_WriteBackFull, M_WriteBackFull_CBWR_Data_M_PDL1C1_0, O, O_ReadShared, O_ReadShared_SnpResp_O_Fwded_S, O_ReadUnique, O_ReadUnique_SnpRespData_I_PD, O_ReadUnique_SnpRespData_I_PDL1C1_0, O_ReadUnique_SnpResp_I, O_ReadUnique_SnpResp_IL1C1_0, O_WriteBackFull, O_WriteBackFull_CBWR_Data_O_PDL1C1_0, O_WriteBackFull_CBWR_Data_O_PDL1C1_1, S, S_ReadShared, S_ReadSharedL1C1_0, S_ReadUnique, S_ReadUniqueL1C1_0, S_ReadUniqueL1C1_1, S_ReadUnique_SnpResp_I, S_ReadUnique_SnpResp_IL1C1_0, S_WriteBackFull}, StallmemQueue_in) {
      recyclememQueue_in;
  }
  
  transition({E, E_ReadShared, E_ReadShared_SnpResp_O_Fwded_S, E_ReadShared_SnpResp_S_Fwded_S, E_ReadUnique, E_ReadUnique_SnpResp_I_Fwded_M_PD, E_WriteBackFull, E_WriteBackFull_CBWR_Data_M_PDL1C1_0, I, I_ReadShared, I_ReadSharedL1C1_0, I_ReadUnique, I_ReadUniqueL1C1_0, I_WriteBackFull, M, M_ReadShared, M_ReadShared_SnpResp_O_Fwded_S, M_ReadUnique, M_ReadUnique_SnpResp_I_Fwded_M_PD, M_WriteBackFull, M_WriteBackFull_CBWR_Data_M_PDL1C1_0, O, O_ReadShared, O_ReadShared_SnpResp_O_Fwded_S, O_ReadUnique, O_ReadUnique_SnpRespData_I_PD, O_ReadUnique_SnpRespData_I_PDL1C1_0, O_ReadUnique_SnpResp_I, O_ReadUnique_SnpResp_IL1C1_0, O_WriteBackFull, O_WriteBackFull_CBWR_Data_O_PDL1C1_0, O_WriteBackFull_CBWR_Data_O_PDL1C1_1, S, S_ReadShared, S_ReadSharedL1C1_0, S_ReadUnique, S_ReadUniqueL1C1_0, S_ReadUniqueL1C1_1, S_ReadUnique_SnpResp_I, S_ReadUnique_SnpResp_IL1C1_0, S_WriteBackFull}, Stallreqto_in) {
      recyclereqto_in;
  }
  
  transition({E, E_ReadShared, E_ReadShared_SnpResp_O_Fwded_S, E_ReadShared_SnpResp_S_Fwded_S, E_ReadUnique, E_ReadUnique_SnpResp_I_Fwded_M_PD, E_WriteBackFull, E_WriteBackFull_CBWR_Data_M_PDL1C1_0, I, I_ReadShared, I_ReadSharedL1C1_0, I_ReadUnique, I_ReadUniqueL1C1_0, I_WriteBackFull, M, M_ReadShared, M_ReadShared_SnpResp_O_Fwded_S, M_ReadUnique, M_ReadUnique_SnpResp_I_Fwded_M_PD, M_WriteBackFull, M_WriteBackFull_CBWR_Data_M_PDL1C1_0, O, O_ReadShared, O_ReadShared_SnpResp_O_Fwded_S, O_ReadUnique, O_ReadUnique_SnpRespData_I_PD, O_ReadUnique_SnpRespData_I_PDL1C1_0, O_ReadUnique_SnpResp_I, O_ReadUnique_SnpResp_IL1C1_0, O_WriteBackFull, O_WriteBackFull_CBWR_Data_O_PDL1C1_0, O_WriteBackFull_CBWR_Data_O_PDL1C1_1, S, S_ReadShared, S_ReadSharedL1C1_0, S_ReadUnique, S_ReadUniqueL1C1_0, S_ReadUniqueL1C1_1, S_ReadUnique_SnpResp_I, S_ReadUnique_SnpResp_IL1C1_0, S_WriteBackFull}, Stallrspto_in) {
      recyclerspto_in;
  }
  
  transition({E, E_ReadShared, E_ReadShared_SnpResp_O_Fwded_S, E_ReadShared_SnpResp_S_Fwded_S, E_ReadUnique, E_ReadUnique_SnpResp_I_Fwded_M_PD, E_WriteBackFull, E_WriteBackFull_CBWR_Data_M_PDL1C1_0, I, I_ReadShared, I_ReadSharedL1C1_0, I_ReadUnique, I_ReadUniqueL1C1_0, I_WriteBackFull, M, M_ReadShared, M_ReadShared_SnpResp_O_Fwded_S, M_ReadUnique, M_ReadUnique_SnpResp_I_Fwded_M_PD, M_WriteBackFull, M_WriteBackFull_CBWR_Data_M_PDL1C1_0, O, O_ReadShared, O_ReadShared_SnpResp_O_Fwded_S, O_ReadUnique, O_ReadUnique_SnpRespData_I_PD, O_ReadUnique_SnpRespData_I_PDL1C1_0, O_ReadUnique_SnpResp_I, O_ReadUnique_SnpResp_IL1C1_0, O_WriteBackFull, O_WriteBackFull_CBWR_Data_O_PDL1C1_0, O_WriteBackFull_CBWR_Data_O_PDL1C1_1, S, S_ReadShared, S_ReadSharedL1C1_0, S_ReadUnique, S_ReadUniqueL1C1_0, S_ReadUniqueL1C1_1, S_ReadUnique_SnpResp_I, S_ReadUnique_SnpResp_IL1C1_0, S_WriteBackFull}, Stallsnpto_in) {
      recyclesnpto_in;
  }
  
  transition({E, E_ReadShared, E_ReadShared_SnpResp_O_Fwded_S, E_ReadShared_SnpResp_S_Fwded_S, E_ReadUnique, E_ReadUnique_SnpResp_I_Fwded_M_PD, E_WriteBackFull, E_WriteBackFull_CBWR_Data_M_PDL1C1_0, I, I_ReadShared, I_ReadSharedL1C1_0, I_ReadUnique, I_ReadUniqueL1C1_0, I_WriteBackFull, M, M_ReadShared, M_ReadShared_SnpResp_O_Fwded_S, M_ReadUnique, M_ReadUnique_SnpResp_I_Fwded_M_PD, M_WriteBackFull, M_WriteBackFull_CBWR_Data_M_PDL1C1_0, O, O_ReadShared, O_ReadShared_SnpResp_O_Fwded_S, O_ReadUnique, O_ReadUnique_SnpRespData_I_PD, O_ReadUnique_SnpRespData_I_PDL1C1_0, O_ReadUnique_SnpResp_I, O_ReadUnique_SnpResp_IL1C1_0, O_WriteBackFull, O_WriteBackFull_CBWR_Data_O_PDL1C1_0, O_WriteBackFull_CBWR_Data_O_PDL1C1_1, S, S_ReadShared, S_ReadSharedL1C1_0, S_ReadUnique, S_ReadUniqueL1C1_0, S_ReadUniqueL1C1_1, S_ReadUnique_SnpResp_I, S_ReadUnique_SnpResp_IL1C1_0, S_WriteBackFull}, Progress) {
      empty;
  }
  
  transition({E_ReadShared_SnpResp_S_Fwded_S, O_ReadUnique_SnpRespData_I_PD, M_ReadUnique, S_ReadUnique, M_ReadUnique_SnpResp_I_Fwded_M_PD, S, O_ReadShared, E_ReadShared_SnpResp_O_Fwded_S, I_ReadShared, O_WriteBackFull, S_ReadUnique_SnpResp_I, M_WriteBackFull, E, O_ReadShared_SnpResp_O_Fwded_S, E_ReadUnique, I_ReadUnique, M_ReadShared, O_ReadUnique_SnpResp_I, S_WriteBackFull, E_WriteBackFull, O, O_ReadUnique, E_ReadUnique_SnpResp_I_Fwded_M_PD, I_WriteBackFull, M_ReadShared_SnpResp_O_Fwded_S, E_ReadShared, M, I, S_ReadShared}, allocTBE) {
    a_allocTBE;
  }
  
  transition({E_ReadShared_SnpResp_S_Fwded_S, O_ReadUnique_SnpRespData_I_PD, M_ReadUnique, S_ReadUnique, M_ReadUnique_SnpResp_I_Fwded_M_PD, S, O_ReadShared, E_ReadShared_SnpResp_O_Fwded_S, I_ReadShared, O_WriteBackFull, S_ReadUnique_SnpResp_I, M_WriteBackFull, E, O_ReadShared_SnpResp_O_Fwded_S, E_ReadUnique, I_ReadUnique, M_ReadShared, O_ReadUnique_SnpResp_I, S_WriteBackFull, E_WriteBackFull, O, O_ReadUnique, E_ReadUnique_SnpResp_I_Fwded_M_PD, I_WriteBackFull, M_ReadShared_SnpResp_O_Fwded_S, E_ReadShared, M, I, S_ReadShared}, deallocTBE) {
    a_deallocTBE;
  }
}
// EOF<directory>
