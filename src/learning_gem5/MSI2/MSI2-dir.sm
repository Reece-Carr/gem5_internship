//SLICC.ModularSLICC.dir.GenDirHeader
machine(MachineType:Directory, "Directory protocol")
:

  DirectoryMemory *directory;
  // The following latencies should be exposed as command-line parameters in a future update
  Cycles toMemLatency := 5;
  Cycles toDMALatency := 10;
  Cycles responseLatency := 1;

  // Required networks
  MessageBuffer *requestToMemory;
  MessageBuffer *responseFromMemory;
  MessageBuffer *conditionQueue;

  // Dynamic networks
  MessageBuffer *respTo, network="From", virtual_network="0", vnet_type="resp";
  MessageBuffer *respFrom, network="To", virtual_network="0", vnet_type="resp";
  MessageBuffer *fwdTo, network="From", virtual_network="1", vnet_type="fwd";
  MessageBuffer *fwdFrom, network="To", virtual_network="1", vnet_type="fwd";
  MessageBuffer *reqTo, network="From", virtual_network="2", vnet_type="req";
  MessageBuffer *reqFrom, network="To", virtual_network="2", vnet_type="req";

{
  //SLICC.ModularSLICC.dir.GenDirStateDecl
  state_declaration(State, desc="Directory states", default="Directory_State_I") {
    M, AccessPermission:Invalid, desc="... TODO ...";
    S, AccessPermission:Read_Only, desc="... TODO ...";
    M_GetS, AccessPermission:Invalid, desc="... TODO ...";
    I, AccessPermission:Read_Write, desc="... TODO ..."; 
    I_GetM__M, AccessPermission:Busy, desc="... TODO ...";
    I_GetS__S, AccessPermission:Busy, desc="... TODO ...";
    I_PutM_COND_ownerPutMsrc_I, AccessPermission:Busy, desc="... TODO ...";
    I_Upgrade__M, AccessPermission:Busy, desc="... TODO ...";
    M_PutM_COND_ownerPutMsrc_I, AccessPermission:Busy, desc="... TODO ...";
    M_GetS_WB_COND_WBsrcowner_S, AccessPermission:Busy, desc="... TODO ...";
    S_GetM_COND_SETFUNC_cachecontainsUpgradesrc_M, AccessPermission:Busy, desc="... TODO ...";
    S_GetM_NCOND_SETFUNC_cachecontainsUpgradesrc_M, AccessPermission:Busy, desc="... TODO ...";
    S_GetS__S, AccessPermission:Busy, desc="... TODO ...";
    S_PutM_COND_ownerPutMsrc_S, AccessPermission:Busy, desc="... TODO ...";
    S_Upgrade_COND_SETFUNC_cachecontainsUpgradesrc_M, AccessPermission:Busy, desc="... TODO ...";
    S_Upgrade_NCOND_SETFUNC_cachecontainsUpgradesrc_M, AccessPermission:Busy, desc="... TODO ...";
    I_PutM_branch_respto, AccessPermission: Busy, desc="...";
    M_PutM_branch_respto, AccessPermission: Busy, desc="...";
    M_GetS_branch_respto, AccessPermission: Busy, desc="...";
    M_GetS_WB_branch_respto, AccessPermission: Busy, desc="...";
    S_GetM_branch_respto, AccessPermission: Busy, desc="...";
    S_PutS_branch_respto, AccessPermission: Busy, desc="...";
    S_PutM_branch_respto, AccessPermission: Busy, desc="...";
    I_PutM_branch_fwdto, AccessPermission: Busy, desc="...";
    M_PutM_branch_fwdto, AccessPermission: Busy, desc="...";
    M_GetS_branch_fwdto, AccessPermission: Busy, desc="...";
    M_GetS_WB_branch_fwdto, AccessPermission: Busy, desc="...";
    S_GetM_branch_fwdto, AccessPermission: Busy, desc="...";
    S_PutS_branch_fwdto, AccessPermission: Busy, desc="...";
    S_PutM_branch_fwdto, AccessPermission: Busy, desc="...";
    I_PutM_branch_reqto, AccessPermission: Busy, desc="...";
    M_PutM_branch_reqto, AccessPermission: Busy, desc="...";
    M_GetS_branch_reqto, AccessPermission: Busy, desc="...";
    M_GetS_WB_branch_reqto, AccessPermission: Busy, desc="...";
    S_GetM_branch_reqto, AccessPermission: Busy, desc="...";
    S_PutS_branch_reqto, AccessPermission: Busy, desc="...";
    S_PutM_branch_reqto, AccessPermission: Busy, desc="...";
    I_DMA_WRITE_I, AccessPermission:Busy, desc="...";
    I_DMA_READ_I, AccessPermission:Busy, desc="...";
    S_DMA_WRITE, AccessPermission:Busy, desc="...";
    S_DMA_I, AccessPermission:Busy, desc="...";
    S_DMA_READ_S, AccessPermission:Busy, desc="...";
    M_DMA_WRITE, AccessPermission:Busy, desc="...";
    M_DMA_WRITE_I, AccessPermission:Busy, desc="...";
  }
  //SLICC.ModularSLICC.dir.GenDirEvents
  enumeration(Event, desc="Directory events") {
    Stall, desc="Stall, please!";
    GetM_Ack_D, desc="Only used for M -- DMA_WRITE --> I";
    DMA_ALL_ACKS, desc="...";
    DMA_READ, desc="...";
    DMA_WRITE, desc="...";
    branchOutcome_1, desc="...";
    branchOutcome_2, desc="...";
    Memory_Read, desc="...";
    Memory_Write, desc="...";
    IGetMEvent, desc="Trynna fix this";
    IGetSEvent, desc="Trynna fix this";
    PutM_fwdto, desc="...";
    PutS_fwdto, desc="...";
    GetM_fwdto, desc="...";
    GetS_fwdto, desc="...";
    WB_fwdto, desc="...";
    PutM_respto, desc="...";
    PutS_respto, desc="...";
    GetM_respto, desc="...";
    GetS_respto, desc="...";
    WB_respto, desc="...";
    PutM_reqto, desc="...";
    PutS_reqto, desc="...";
    GetM_reqto, desc="...";
    GetS_reqto, desc="...";
    WB_reqto, desc="...";
  }
  //SLICC.ModularSLICC.dir.GenDirStruct
  structure(Entry, desc="Stored variables of the Directory machine", interface="AbstractCacheEntry", main="false") {
    State DirectoryState, desc="Directory state";
    DataBlock clL1, desc="... TODO ...";
    NetDest cacheL1L1, desc="... TODO ...";
    MachineID ownerL1, desc="... TODO ...";
  }
  //SLICC.ModularSLICC.dir.GenDirTBE
  structure(TBE, desc="TBE entries for Directory machine") {
    Addr PhysicalAddress, desc="physical address";
    State TBEState,       desc="Transient State";
    DataBlock DataBlk,    desc="Data to be written";
    int Len,              desc="Length of data block to write";
  }
  
  structure(TBETable, external="yes"){
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
  }
  
  TBETable TBEs, template="<Directory_TBE>", constructor="m_number_of_TBEs";
  
  void set_tbe(TBE b);
  void unset_tbe();
  //SLICC.ModularSLICC.dir.GenDirStaticFns
  Tick clockEdge();
  Tick cyclesToTicks(Cycles c);
  
  Entry getDirectoryEntry(Addr LineAddress), return_by_pointer = "yes" {
    Entry entry := static_cast(Entry, "pointer", directory[LineAddress]);
    if (is_invalid(entry)) {
      entry := static_cast(Entry, "pointer", directory.allocate(LineAddress, new Entry));
    }
    return entry;
  }
  
  State getState(TBE tbe, Addr LineAddress) {
    if (is_valid(tbe)) {
      return tbe.TBEState;
    } else if (directory.isPresent(LineAddress)) {
      return getDirectoryEntry(LineAddress).DirectoryState;
    } else {
      return State:I;
    }
  }
  
  void setState(TBE tbe, Addr LineAddress, State state) {
    if (is_valid(tbe)) {
      tbe.TBEState := state;
    }
    if (directory.isPresent(LineAddress)) {
      getDirectoryEntry(LineAddress).DirectoryState := state;

      if (state == State:I || state == State:M) {
        assert(getDirectoryEntry(LineAddress).cacheL1L1.count() == 0);
      }
      if (state == State:S) {
        assert(getDirectoryEntry(LineAddress).cacheL1L1.count() > 0);
      }
    }
  }
  
  AccessPermission getAccessPermission(Addr LineAddress) {
    TBE tbe := TBEs[LineAddress];
    if (is_valid(tbe)) {
      return Directory_State_to_permission(tbe.TBEState);
    } else if (directory.isPresent(LineAddress)) {
      return Directory_State_to_permission(getDirectoryEntry(LineAddress).DirectoryState);
    } else {
      return AccessPermission:NotPresent;
    }
  }
  
  void setAccessPermission(Addr LineAddress, State state) {
    if (directory.isPresent(LineAddress)) {
      getDirectoryEntry(LineAddress).changePermission(Directory_State_to_permission(state));
    }
  }
  
  void functionalRead(Addr LineAddress, Packet *pkt) {
    TBE tbe := TBEs[LineAddress];
    if (is_valid(tbe)) {
      testAndRead(LineAddress, tbe.DataBlk, pkt);
    } else {
      functionalMemoryRead(pkt);
    }
  }
  
  int functionalWrite(Addr LineAddress, Packet *pkt) {
    int num_functional_writes := 0;
  
    TBE tbe := TBEs[LineAddress];
    if (is_valid(tbe)) {
      num_functional_writes := num_functional_writes + testAndWrite(LineAddress, tbe.DataBlk, pkt);
    }
  
    num_functional_writes := num_functional_writes + functionalMemoryWrite(pkt);
    return num_functional_writes;
  }
  //SLICC.ModularSLICC.dir.GenDirOutPorts
  out_port(conditionQueue_out, CondMsg, conditionQueue);
  out_port(memQueue_out, MemoryMsg, requestToMemory);
  out_port(fwdfrom_out, CoherenceMessage, fwdFrom);
  out_port(reqfrom_out, CoherenceMessage, reqFrom);
  out_port(respfrom_out, CoherenceMessage, respFrom);
  in_port(conditionQueue_in, CondMsg, conditionQueue) {
    if (conditionQueue_in.isReady(clockEdge())) {
      peek (conditionQueue_in, CondMsg) {
        TBE tbe := TBEs[in_msg.LineAddress];
        Entry entry := getDirectoryEntry(in_msg.LineAddress);
        State st := getState(tbe, in_msg.LineAddress);
        Addr LineAddress := in_msg.LineAddress;
        if (in_msg.Net == 1) {
          // Net == 1 -> Net == respto_in
          if (st == State:I_PutM_branch_respto || st == State:S_PutM_branch_respto
              || st == State:M_GetS_WB_branch_respto) {
            if (entry.ownerL1 == in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.ownerL1 != in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unedxpected branch outcome");
            }
          } else if (st == State:M_PutM_branch_respto) {
            if (entry.ownerL1 == in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.ownerL1 != in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unedxpected branch outcome");
            }
          } else if (st == State:M_GetS_branch_respto) {
            if (entry.ownerL1 == in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.ownerL1 != in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unedxpected branch outcome");
            }
          } else if (st == State:S_GetM_branch_respto) {
            if (entry.cacheL1L1.isElement(in_msg.OriginalSender))  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            }
          } else if (st == State:S_PutS_branch_respto) {
            if (entry.cacheL1L1.count() == 0)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.cacheL1L1.count() != 0)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unedxpected branch outcome");
            }
          } else {
            error("Got CondMsg in unexpected state");
          }
        } else if (in_msg.Net == 2) {
          // Net == 2 -> Net == fwdto_in
          if (st == State:I_PutM_branch_fwdto || st == State:S_PutM_branch_fwdto || st == State:M_GetS_WB_branch_respto) {
            if (entry.ownerL1 == in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.ownerL1 != in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unedxpected branch outcome");
            }
          } else if (st == State:M_PutM_branch_fwdto) {
            if (entry.ownerL1 == in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.ownerL1 != in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unedxpected branch outcome");
            }
          } else if (st == State:M_GetS_branch_fwdto) {
            if (entry.ownerL1 == in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.ownerL1 != in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unedxpected branch outcome");
            }
          } else if (st == State:S_GetM_branch_fwdto) {
            if (entry.cacheL1L1.isElement(in_msg.OriginalSender))  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } 
          } else if (st == State:S_PutS_branch_fwdto) {
            if (entry.cacheL1L1.count() == 0)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.cacheL1L1.count() != 0)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unedxpected branch outcome");
            }
          } else {
            error("Got CondMsg in unexpected state");
          }
        } else if (in_msg.Net == 0) {
          // Net == 0 -> Net == reqto_in
          if (st == State:I_PutM_branch_reqto || st == State:S_PutM_branch_reqto
              || st == State:M_GetS_WB_branch_reqto) {
            if (entry.ownerL1 == in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.ownerL1 != in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unexpected branch outcome");
            }
          } else if (st == State:M_PutM_branch_reqto) {
            if (entry.ownerL1 == in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.ownerL1 != in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unexpected branch outcome");
            }
          } else if (st == State:M_GetS_branch_reqto) {
            if (entry.ownerL1 == in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.ownerL1 != in_msg.OriginalSender)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unexpected branch outcome");
            }
          } else if (st == State:S_GetM_branch_reqto) {
            if (entry.cacheL1L1.isElement(in_msg.OriginalSender))  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            }
          } else if (st == State:S_PutS_branch_reqto) {
            if (entry.cacheL1L1.count() == 0)  {
              trigger(Event:branchOutcome_1, LineAddress, tbe);
            } else if (entry.cacheL1L1.count() != 0)  {
              trigger(Event:branchOutcome_2, LineAddress, tbe);
            } else {
              error("Unexpected branch outcome");
            }
          } else {
            error("Got CondMsg in unexpected state");
          }
        } else {
          error("Unrecognized net in condQueue");
        }
      }
    }
  }
  //SLICC.ModularSLICC.dir.GenDirInPorts
  in_port(memQueue_in, MemoryMsg, responseFromMemory) {
    if (memQueue_in.isReady(clockEdge())) {
      peek(memQueue_in, MemoryMsg) {
        TBE tbe := TBEs[in_msg.addr];
        Addr LineAddress := in_msg.addr;
        State st := getState(tbe, LineAddress);
        //DPRINTF(RubySlicc, "Dir at address 0x%x received message %d in state %d, net=memQueue_in\n", LineAddress, in_msg.Type, st);
        if (st == State:I_GetM__M 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          trigger(Event:Memory_Read, LineAddress, tbe);
        } else if (st == State:S_DMA_READ_S
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          trigger(Event:Memory_Read, LineAddress, tbe);
        } else if (st == State:I_DMA_READ_I
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          trigger(Event:Memory_Read, LineAddress, tbe);
        } else if (st == State:I_GetS__S 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          trigger(Event:Memory_Read, LineAddress, tbe);
        } else if (st == State:I_PutM_COND_ownerPutMsrc_I 
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          trigger(Event:Memory_Write, LineAddress, tbe);
        } else if (st == State:I_Upgrade__M 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          trigger(Event:Memory_Read, LineAddress, tbe);
        } else if (st == State:M_PutM_COND_ownerPutMsrc_I 
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          trigger(Event:Memory_Write, LineAddress, tbe);
        } else if (st == State:M_DMA_WRITE_I
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          trigger(Event:Memory_Write, LineAddress, tbe);
        } else if (st == State:S_DMA_I
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          trigger(Event:Memory_Write, LineAddress, tbe);
        } else if (st == State:I_DMA_WRITE_I
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          trigger(Event:Memory_Write, LineAddress, tbe);
        } else if (st == State:M_GetS_WB_COND_WBsrcowner_S 
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          trigger(Event:Memory_Write, LineAddress, tbe);
        } else if (st == State:S_GetM_COND_SETFUNC_cachecontainsUpgradesrc_M 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          trigger(Event:Memory_Read, LineAddress, tbe);
        } else if (st == State:S_GetM_NCOND_SETFUNC_cachecontainsUpgradesrc_M 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          trigger(Event:Memory_Read, LineAddress, tbe);
        } else if (st == State:S_GetS__S 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          trigger(Event:Memory_Read, LineAddress, tbe);
        } else if (st == State:S_PutM_COND_ownerPutMsrc_S 
              && in_msg.Type == MemoryRequestType:MEMORY_WB) {
          trigger(Event:Memory_Write, LineAddress, tbe);
        } else if (st == State:S_Upgrade_COND_SETFUNC_cachecontainsUpgradesrc_M 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          trigger(Event:Memory_Read, LineAddress, tbe);
        } else if (st == State:S_Upgrade_NCOND_SETFUNC_cachecontainsUpgradesrc_M 
              && in_msg.Type == MemoryRequestType:MEMORY_READ) {
          trigger(Event:Memory_Read, LineAddress, tbe);
        } else {
          error("Dir received memory message in unexpected state");
        }
      }
    }
  }
  in_port(respto_in, CoherenceMessage, respTo) {
    if (respto_in.isReady(clockEdge())) {
      peek (respto_in, CoherenceMessage) {
        TBE tbe := TBEs[in_msg.LineAddress];
        State st := getState(tbe, in_msg.LineAddress);
        Addr LineAddress := in_msg.LineAddress;
        //////DPRINTF(RubySlicc, "Dir at address 0x%x received message %d in state %d, net=respto_in\n", LineAddress, in_msg.Type, st);
        if (st == State:I) {
          if (in_msg.Type == CoherenceMessageType:GetM) {
            trigger(Event:GetM_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:GetS) {
            trigger(Event:GetS_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutM) {
            trigger(Event:PutM_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutS) {
            trigger(Event:PutS_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:Upgrade) {
            trigger(Event:GetM_respto, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else if (st == State:M_DMA_WRITE && in_msg.Type == CoherenceMessageType:GetM_Ack_D) {
            trigger(Event:GetM_Ack_D, LineAddress, tbe);
        } else if (st == State:S_DMA_WRITE && in_msg.Type == CoherenceMessageType:DMA_ALL_ACKS) {
            trigger(Event:DMA_ALL_ACKS, LineAddress, tbe);
        } else if (st == State:M) {      
          if (in_msg.Type == CoherenceMessageType:GetM) {
            trigger(Event:GetM_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:GetS) {
            trigger(Event:GetS_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutM) {
            trigger(Event:PutM_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutS) {
            trigger(Event:PutS_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:Upgrade) {
            trigger(Event:GetM_respto, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else if (st == State:M_GetS) {      
          if (in_msg.Type == CoherenceMessageType:WB) {
            trigger(Event:WB_respto, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else if (st == State:S) {      
          if (in_msg.Type == CoherenceMessageType:GetM) {
            trigger(Event:GetM_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:GetS) {
            trigger(Event:GetS_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutM) {
            trigger(Event:PutM_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutS) {
            trigger(Event:PutS_respto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:Upgrade) {
            trigger(Event:GetM_respto, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else {
          trigger(Event:Stall, LineAddress, tbe);
        }
      }
    }
  }
  in_port(fwdto_in, CoherenceMessage, fwdTo) {
    if (fwdto_in.isReady(clockEdge())) {
      peek (fwdto_in, CoherenceMessage) {
        TBE tbe := TBEs[in_msg.LineAddress];
        State st := getState(tbe, in_msg.LineAddress);
        Addr LineAddress := in_msg.LineAddress;
        //////DPRINTF(RubySlicc, "Dir at address 0x%x received message %d in state %d, net=fwdto_in\n", LineAddress, in_msg.Type, st);
        if (st == State:I) {
          if (in_msg.Type == CoherenceMessageType:GetM) {
            trigger(Event:GetM_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:GetS) {
            trigger(Event:GetS_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutM) {
            trigger(Event:PutM_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutS) {
            trigger(Event:PutS_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:Upgrade) {
            trigger(Event:GetM_fwdto, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else if (st == State:M) {      
          if (in_msg.Type == CoherenceMessageType:GetM) {
            trigger(Event:GetM_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:GetS) {
            trigger(Event:GetS_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutM) {
            trigger(Event:PutM_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutS) {
            trigger(Event:PutS_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:Upgrade) {
            trigger(Event:GetM_fwdto, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else if (st == State:M_GetS) {      
          if (in_msg.Type == CoherenceMessageType:WB) {
            trigger(Event:WB_fwdto, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else if (st == State:S) {      
          if (in_msg.Type == CoherenceMessageType:GetM) {
            trigger(Event:GetM_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:GetS) {
            trigger(Event:GetS_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutM) {
            trigger(Event:PutM_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutS) {
            trigger(Event:PutS_fwdto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:Upgrade) {
            trigger(Event:GetM_fwdto, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else {
          trigger(Event:Stall, LineAddress, tbe);
        }
      }
    }
  }
  in_port(reqto_in, CoherenceMessage, reqTo) {
    if (reqto_in.isReady(clockEdge())) {
      peek (reqto_in, CoherenceMessage) {
        TBE tbe := TBEs[in_msg.LineAddress];
        State st := getState(tbe, in_msg.LineAddress);
        Addr LineAddress := in_msg.LineAddress;
        //////DPRINTF(RubySlicc, "Dir at address 0x%x received message %d in state %d, net=reqto_in\n", LineAddress, in_msg.Type, st);
        if (st == State:I) {
          if (in_msg.Type == CoherenceMessageType:GetM) {
            trigger(Event:GetM_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:GetS) {
            trigger(Event:GetS_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutM) {
            trigger(Event:PutM_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutS) {
            trigger(Event:PutS_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:Upgrade) {
            trigger(Event:GetM_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:DMA_READ) {
            trigger(Event:DMA_READ, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:DMA_WRITE) {
            trigger(Event:DMA_WRITE, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else if (st == State:M) {      
          if (in_msg.Type == CoherenceMessageType:GetM) {
            trigger(Event:GetM_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:GetS) {
            trigger(Event:GetS_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutM) {
            trigger(Event:PutM_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutS) {
            trigger(Event:PutS_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:Upgrade) {
            trigger(Event:GetM_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:DMA_READ) {
            trigger(Event:DMA_READ, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:DMA_WRITE) {
            trigger(Event:DMA_WRITE, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else if (st == State:M_GetS) {      
          if (in_msg.Type == CoherenceMessageType:WB) {
            trigger(Event:WB_reqto, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else if (st == State:S) {      
          if (in_msg.Type == CoherenceMessageType:GetM) {
            trigger(Event:GetM_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:GetS) {
            trigger(Event:GetS_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutM) {
            trigger(Event:PutM_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:PutS) {
            trigger(Event:PutS_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:Upgrade) {
            trigger(Event:GetM_reqto, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:DMA_READ) {
            trigger(Event:DMA_READ, LineAddress, tbe);
          } else if (in_msg.Type == CoherenceMessageType:DMA_WRITE) {
            trigger(Event:DMA_WRITE, LineAddress, tbe);
          } else {
            trigger(Event:Stall, LineAddress, tbe);
          }
        } else {
          trigger(Event:Stall, LineAddress, tbe);
        }
      }
    }
  }

  action(a_allocate_TBE_for_DMA, "aTfD", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      TBEs.allocate(address);
      set_tbe(TBEs[address]);
      tbe.PhysicalAddress := in_msg.PhysicalAddress;
      tbe.DataBlk := in_msg.cl;
      tbe.Len := in_msg.Len;
    }
  }

  action(a_sendPartialMemoryWB_reqto, "asPMWBreq", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      enqueue(memQueue_out, MemoryMsg, toMemLatency) {
        out_msg.DataBlk := tbe.DataBlk;
        out_msg.addr := address;
        out_msg.Type := MemoryRequestType:MEMORY_WB;
        out_msg.Sender := in_msg.Sender;
        out_msg.MessageSize := MessageSizeType:Request_Control;
        out_msg.Len := tbe.Len;
      }
    }
  }
  action(a_sendPartialMemoryWB_respto, "asPMWBresp", desc="...") {
    peek(respto_in, CoherenceMessage) {
      enqueue(memQueue_out, MemoryMsg, toMemLatency) {
        out_msg.DataBlk := tbe.DataBlk;
        out_msg.addr := address;
        out_msg.Type := MemoryRequestType:MEMORY_WB;
        out_msg.Sender := in_msg.Sender;
        out_msg.MessageSize := MessageSizeType:Request_Control;
        out_msg.Len := tbe.Len;
      }
    }
  }

  action(a_send_DMA_ACK, "asDA", desc="...") {
    peek(memQueue_in, MemoryMsg) {
      enqueue(respfrom_out, CoherenceMessage, responseLatency) {
        out_msg.LineAddress := address;
        out_msg.MessageSize := MessageSizeType:Data;
        out_msg.Destination.add(in_msg.OriginalRequestorMachId);
        out_msg.Type := CoherenceMessageType:DMA_ACK;
        out_msg.Sender := machineID;
      }
    }
  }
  action(a_I_DMA_READ, "aIDR", desc="...") {
    peek(memQueue_in, MemoryMsg) {
      enqueue(respfrom_out, CoherenceMessage, responseLatency) {
        out_msg.LineAddress := address;
        out_msg.MessageSize := MessageSizeType:Data;
        out_msg.Destination.add(in_msg.OriginalRequestorMachId);
        out_msg.Type := CoherenceMessageType:GetS_Ack;
        out_msg.Sender := machineID;
        out_msg.cl := in_msg.DataBlk;
      }
    }
  }
  action(a_S_DMA_WRITE, "aSDW", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
      enqueue(respfrom_out, CoherenceMessage, responseLatency) {
        out_msg.LineAddress := address;
        out_msg.MessageSize := MessageSizeType:Data;
        out_msg.Destination.add(in_msg.Sender);
        out_msg.Type := CoherenceMessageType:GetM_Ack_AD;
        out_msg.Sender := machineID;
        out_msg.cl := in_msg.cl;
        out_msg.acksExpected := entry.cacheL1L1.count();
      }
      enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
        out_msg.LineAddress := address;
        out_msg.MessageSize := MessageSizeType:Data;
        out_msg.Destination := entry.cacheL1L1;
        out_msg.Type := CoherenceMessageType:Inv;
        out_msg.Sender := in_msg.Sender;
      }
      entry.cacheL1L1.clear();
    }
  }
  action(a_send_Fwd_GetM, "asFGM", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
      enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
        out_msg.LineAddress := address;
        out_msg.MessageSize := MessageSizeType:Data;
        out_msg.Destination.add(entry.ownerL1);
        out_msg.Type := CoherenceMessageType:Fwd_GetM;
        out_msg.Sender := in_msg.Sender;
      }
    }
  }

  action(a_sendPartialMemoryWB_GetM_Ack_D, "asPMWB_GMAD", desc="...") {
    peek(respto_in, CoherenceMessage) {
      assert(is_valid(tbe));
      DataBlock DataBlk := in_msg.cl;
      DataBlk.copyPartial(tbe.DataBlk, getOffset(tbe.PhysicalAddress),
                          tbe.Len);
      peek(respto_in, CoherenceMessage) {
        enqueue(memQueue_out, MemoryMsg, toMemLatency) {
          out_msg.DataBlk := DataBlk;
          out_msg.addr := address;
          out_msg.Type := MemoryRequestType:MEMORY_WB;
          out_msg.Sender := in_msg.Sender;
          out_msg.MessageSize := MessageSizeType:Request_Control;
          out_msg.Len := 0;
        }
      }
    }
  }

  action(stall, "\z", desc="...") {
      // z_stall
  }

  action(queueBranch_respto, "qB_respfrom", desc="...") {
    peek(respto_in, CoherenceMessage) {
    enqueue(conditionQueue_out, CondMsg) {
      out_msg.LineAddress := address;
      out_msg.Net := 1;
      out_msg.OriginalSender := in_msg.Sender;
    }
    }
  }
  action(queueBranch_fwdto, "qB_fwdfrom", desc="...") {
    peek(fwdto_in, CoherenceMessage) {
    enqueue(conditionQueue_out, CondMsg) {
      out_msg.LineAddress := address;
      out_msg.Net := 2;
      out_msg.OriginalSender := in_msg.Sender;
    }
  }
  }
  action(queueBranch_reqto, "qB_reqfrom", desc="...") {
    peek(reqto_in, CoherenceMessage) {
    enqueue(conditionQueue_out, CondMsg) {
      out_msg.LineAddress := address;
      out_msg.Net := 0;
      out_msg.OriginalSender := in_msg.Sender;
    }
    }
  }
  action(a_ReadMem, "mR", desc="Please work") {
    peek(reqto_in, CoherenceMessage) {
      enqueue(memQueue_out, MemoryMsg, toMemLatency) {
        out_msg.addr := in_msg.LineAddress;
        out_msg.Type := MemoryRequestType:MEMORY_READ;
        out_msg.Sender := in_msg.Sender;
        out_msg.MessageSize := MessageSizeType:Request_Control;
        out_msg.Len := 0;
      }
    }
  }
  
  action(a_popreqto, "p", desc="Pop reqto_in") {
    reqto_in.dequeue(clockEdge());
  }
  action(a_poprespto, "pResp", desc="Pop respto_in") {
    respto_in.dequeue(clockEdge());
  }
  action(a_popfwdto, "pFwd", desc="Pop fwdto_in") {
    fwdto_in.dequeue(clockEdge());
  }

  action(a_popmemq, "pMQ", desc="Pop memqueue") {
    memQueue_in.dequeue(clockEdge());
  }
  action(a_popcondq, "pcQ_in0", desc="Pop the condition queue.") {
      // Sometimes we need to be able to pop a queue/in_port from within a transition
      // rather than from within the in_port itself. Thus, we need an action for this,
      // since transitions cannot execute non-action functions.
      conditionQueue_in.dequeue(clockEdge());
  }

  action(a_I_GetM__M_Memory_Read_M, "aIGMMMRM", desc="...") {
    peek(memQueue_in, MemoryMsg) {
      Entry entry := getDirectoryEntry(address);
      enqueue(respfrom_out, CoherenceMessage, responseLatency) {
        out_msg.LineAddress := address;
        out_msg.MessageSize := MessageSizeType:Data;
        out_msg.Destination.add(in_msg.OriginalRequestorMachId);
        out_msg.Type := CoherenceMessageType:GetM_Ack_AD;
        out_msg.Sender := machineID;
        out_msg.cl := in_msg.DataBlk;
        out_msg.acksExpected := entry.cacheL1L1.count();
      }
      entry.ownerL1 := in_msg.OriginalRequestorMachId;
    }
  }
  action(a_I_GetS__S_Memory_Read_S, "aIGSSMRS", desc="...") {
    peek(memQueue_in, MemoryMsg) {
      Entry entry := getDirectoryEntry(address);
          enqueue(respfrom_out, CoherenceMessage, responseLatency) {
            out_msg.LineAddress := address;
            out_msg.MessageSize := MessageSizeType:Data;
            out_msg.Destination.add(in_msg.OriginalRequestorMachId);
            out_msg.Type := CoherenceMessageType:GetS_Ack;
            out_msg.Sender := machineID;
            out_msg.cl := in_msg.DataBlk;
          }
          entry.cacheL1L1.add(in_msg.OriginalRequestorMachId);
    }
  }
  action(a_I_Upgrade__M_Memory_Read_M, "AIUMMRM", desc="...") {
    peek(memQueue_in, MemoryMsg) {
      Entry entry := getDirectoryEntry(address);
          enqueue(respfrom_out, CoherenceMessage, responseLatency) {
            out_msg.LineAddress := address;
            out_msg.MessageSize := MessageSizeType:Data;
            out_msg.Destination.add(in_msg.OriginalRequestorMachId);
            out_msg.Type := CoherenceMessageType:GetM_Ack_AD;
            out_msg.Sender := machineID;
            out_msg.cl := in_msg.DataBlk;
            out_msg.acksExpected := entry.cacheL1L1.count();
          }
            entry.ownerL1 := in_msg.OriginalRequestorMachId;
      }
  }
  action(a_S_GetM, "aSGM", desc="...") {
    peek(memQueue_in, MemoryMsg) {
      Entry entry := getDirectoryEntry(address);
            enqueue(respfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.OriginalRequestorMachId);
              out_msg.Type := CoherenceMessageType:GetM_Ack_AD;
              out_msg.Sender := machineID;
              out_msg.cl := in_msg.DataBlk;
              out_msg.acksExpected := entry.cacheL1L1.count();
            }
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination := entry.cacheL1L1;
              out_msg.Type := CoherenceMessageType:Inv;
              out_msg.Sender := in_msg.OriginalRequestorMachId;
            }
            entry.ownerL1 := in_msg.OriginalRequestorMachId;
            entry.cacheL1L1.clear();
    }
  }
  action(a_remOGReq, "arOGR", desc="...") {
    peek(memQueue_in, MemoryMsg) {
      Entry entry := getDirectoryEntry(address);
          entry.cacheL1L1.remove(in_msg.OriginalRequestorMachId);
    }
  }
  action(a_S_GetS__S_Memory_Read_S, "aSGSSMRS", desc="...") {
    peek(memQueue_in, MemoryMsg) {
      Entry entry := getDirectoryEntry(address);
          entry.cacheL1L1.add(in_msg.OriginalRequestorMachId);
            enqueue(respfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.OriginalRequestorMachId);
              out_msg.Type := CoherenceMessageType:GetS_Ack;
              out_msg.Sender := machineID;
              out_msg.cl := in_msg.DataBlk;
            }
    }
  }

  action(a_I_PutM_I_PutM_branch_fwdto, "aIPMIPMb_fwdto", desc="...") {
    peek(fwdto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Put_Ack;
              out_msg.Sender := machineID;
            }
            entry.cacheL1L1.remove(in_msg.Sender);
    }
  }
  action(a_I_PutS_I_fwdto, "aIPSI_fwdto", desc="...") {
    peek(fwdto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Put_Ack;
              out_msg.Sender := machineID;
            }
            entry.cacheL1L1.remove(in_msg.Sender);
    }
  }
  action(a_M_GetM_M_fwdto, "aMGMM_fwdto", desc="...") {
    peek(fwdto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(entry.ownerL1);
              out_msg.Type := CoherenceMessageType:Fwd_GetM;
              out_msg.Sender := in_msg.Sender;
            }
            entry.ownerL1 := in_msg.Sender;
    }
  }
  action(a_M_GetS_M_GetS_fwdto, "aMGSMGS_fwdto", desc="...") {
    peek(fwdto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(entry.ownerL1);
              out_msg.Type := CoherenceMessageType:Fwd_GetS;
              out_msg.Sender := in_msg.Sender;
            }
            entry.cacheL1L1.add(in_msg.Sender);
            entry.cacheL1L1.add(entry.ownerL1);
    }
  }
  action(a_S_PutS_S_PutS_branch_fwdto, "aSPSSPSb_fwdto", desc="...") {
    peek(fwdto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Put_Ack;
              out_msg.Sender := machineID;
            }
            entry.cacheL1L1.remove(in_msg.Sender);
    }
  }

  action(a_sendMemRead_fwdto, "asMR_fwdto", desc="...") {
    peek(fwdto_in, CoherenceMessage) {
      enqueue(memQueue_out, MemoryMsg, toMemLatency) {
        out_msg.addr := address;
        out_msg.Type := MemoryRequestType:MEMORY_READ;
        out_msg.Sender := in_msg.Sender;
        out_msg.MessageSize := MessageSizeType:Request_Control;
        out_msg.Len := 0;
      }
    }
  }

  action(a_sendMemWrite_fwdto, "asMW_fwdto", desc="...") {
    peek(fwdto_in, CoherenceMessage) {
      enqueue(memQueue_out, MemoryMsg, toMemLatency) {
        out_msg.DataBlk := in_msg.cl;
        out_msg.addr := address;
        out_msg.Type := MemoryRequestType:MEMORY_WB;
        out_msg.Sender := in_msg.Sender;
        out_msg.MessageSize := MessageSizeType:Request_Control;
        out_msg.Len := 0;
      }
    }
  }
  action(a_I_PutM_I_PutM_branch_respto, "aIPMIPMb_respto", desc="...") {
    peek(respto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Put_Ack;
              out_msg.Sender := machineID;
            }
            entry.cacheL1L1.remove(in_msg.Sender);
    }
  }
  action(a_I_PutS_I_respto, "aIPSI_respto", desc="...") {
    peek(respto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Put_Ack;
              out_msg.Sender := machineID;
            }
            entry.cacheL1L1.remove(in_msg.Sender);
    }
  }
  action(a_M_GetM_M_respto, "aMGMM_respto", desc="...") {
    peek(respto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(entry.ownerL1);
              out_msg.Type := CoherenceMessageType:Fwd_GetM;
              out_msg.Sender := in_msg.Sender;
            }
            entry.ownerL1 := in_msg.Sender;
    }
  }
  action(a_M_GetS_M_GetS_respto, "aMGSMGS_respto", desc="...") {
    peek(respto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(entry.ownerL1);
              out_msg.Type := CoherenceMessageType:Fwd_GetS;
              out_msg.Sender := in_msg.Sender;
            }
            entry.cacheL1L1.add(in_msg.Sender);
            entry.cacheL1L1.add(entry.ownerL1);
    }
  }
  action(a_S_PutS_S_PutS_branch_respto, "aSPSSPSb_respto", desc="...") {
    peek(respto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Put_Ack;
              out_msg.Sender := machineID;
            }
            entry.cacheL1L1.remove(in_msg.Sender);
    }
  }

  action(a_sendMemRead_respto, "asMR_respto", desc="...") {
    peek(respto_in, CoherenceMessage) {
      enqueue(memQueue_out, MemoryMsg, toMemLatency) {
        out_msg.addr := address;
        out_msg.Type := MemoryRequestType:MEMORY_READ;
        out_msg.Sender := in_msg.Sender;
        out_msg.MessageSize := MessageSizeType:Request_Control;
        out_msg.Len := 0;
      }
    }
  }

  action(a_sendMemWrite_respto, "asMW_respto", desc="...") {
    peek(respto_in, CoherenceMessage) {
      enqueue(memQueue_out, MemoryMsg, toMemLatency) {
        out_msg.DataBlk := in_msg.cl;
        out_msg.addr := address;
        out_msg.Type := MemoryRequestType:MEMORY_WB;
        out_msg.Sender := in_msg.Sender;
        out_msg.MessageSize := MessageSizeType:Request_Control;
        out_msg.Len := 0;
      }
    }
  }
  action(a_I_PutM_I_PutM_branch_reqto, "aIPMIPMb_reqto", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Put_Ack;
              out_msg.Sender := machineID;
            }
            entry.cacheL1L1.remove(in_msg.Sender);
    }
  }
  action(a_I_PutS_I_reqto, "aIPSI_reqto", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Put_Ack;
              out_msg.Sender := machineID;
            }
            entry.cacheL1L1.remove(in_msg.Sender);
    }
  }
  action(a_M_GetM_M_reqto, "aMGMM_reqto", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(entry.ownerL1);
              out_msg.Type := CoherenceMessageType:Fwd_GetM;
              out_msg.Sender := in_msg.Sender;
            }
            entry.ownerL1 := in_msg.Sender;
    }
  }
  action(a_M_GetS_M_GetS_reqto, "aMGSMGS_reqto", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(entry.ownerL1);
              out_msg.Type := CoherenceMessageType:Fwd_GetS;
              out_msg.Sender := in_msg.Sender;
            }
            entry.cacheL1L1.add(in_msg.Sender);
            entry.cacheL1L1.add(entry.ownerL1);
    }
  }
  action(a_S_PutS_S_PutS_branch_reqto, "aSPSSPSb_reqto", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(in_msg.Sender);
              out_msg.Type := CoherenceMessageType:Put_Ack;
              out_msg.Sender := machineID;
            }
            entry.cacheL1L1.remove(in_msg.Sender);
    }
  }

  action(a_sendMemRead_reqto, "asMR_reqto", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      enqueue(memQueue_out, MemoryMsg, toMemLatency) {
        out_msg.addr := address;
        out_msg.Type := MemoryRequestType:MEMORY_READ;
        out_msg.Sender := in_msg.Sender;
        out_msg.MessageSize := MessageSizeType:Request_Control;
        out_msg.Len := 0;
      }
    }
  }

  action(a_sendMemWrite_reqto, "asMW_reqto", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      enqueue(memQueue_out, MemoryMsg, toMemLatency) {
        out_msg.DataBlk := in_msg.cl;
        out_msg.addr := address;
        out_msg.Type := MemoryRequestType:MEMORY_WB;
        out_msg.Sender := in_msg.Sender;
        out_msg.MessageSize := MessageSizeType:Request_Control;
        out_msg.Len := 0;
      }
    }
  }
  action(a_M_DMA_READ, "aMDR", desc="...") {
    peek(reqto_in, CoherenceMessage) {
      Entry entry := getDirectoryEntry(address);
            enqueue(fwdfrom_out, CoherenceMessage, responseLatency) {
              out_msg.LineAddress := address;
              out_msg.MessageSize := MessageSizeType:Data;
              out_msg.Destination.add(entry.ownerL1);
              out_msg.Type := CoherenceMessageType:Fwd_GetS;
              out_msg.Sender := in_msg.Sender;
            }
            entry.cacheL1L1.add(entry.ownerL1);
    }
  }

  action(a_deallocate_TBE, "adTBE", desc="...") {
    TBEs.deallocate(address);
    unset_tbe();
  }

  transition(I, IGetMEvent, I_GetM__M) {
    a_ReadMem;
    a_popreqto;
  }
  transition(I, IGetSEvent, I_GetS__S) {
    a_ReadMem;
    a_popreqto;
  }

  // PROPER WAY
  transition(I_GetS__S, Memory_Read, S) {
    a_I_GetS__S_Memory_Read_S;
    a_popmemq;
  }
  transition(I_PutM_COND_ownerPutMsrc_I, Memory_Write, I) {
    a_popmemq;
  }
  transition(M_PutM_COND_ownerPutMsrc_I, Memory_Write, I) {
    a_popmemq;
  }

  transition(M_GetS_WB_COND_WBsrcowner_S, Memory_Write, S) {
    a_popmemq;
  }

  transition({I_Upgrade__M, I_GetM__M}, Memory_Read, M) {
    a_I_Upgrade__M_Memory_Read_M;
    a_popmemq;
  }

  transition({S_GetM_NCOND_SETFUNC_cachecontainsUpgradesrc_M, S_Upgrade_NCOND_SETFUNC_cachecontainsUpgradesrc_M}, Memory_Read, M) {
    a_S_GetM;
    a_popmemq;
  }

  transition({S_GetM_COND_SETFUNC_cachecontainsUpgradesrc_M, S_Upgrade_COND_SETFUNC_cachecontainsUpgradesrc_M}, Memory_Read, M) {
    a_remOGReq;
    a_S_GetM;
    a_popmemq;
  }

  transition(S_GetS__S, Memory_Read, S) {
    a_S_GetS__S_Memory_Read_S;
    a_popmemq;
  }

  transition(S_PutM_COND_ownerPutMsrc_S, Memory_Write, S) {
    a_popmemq;
  }

  transition(I, GetM_respto, I_GetM__M) {
    a_sendMemRead_respto;
    a_poprespto;
  }
  transition(I, GetS_respto, I_GetS__S) {
    a_sendMemRead_respto;
    a_poprespto;
  }

  transition(I, PutM_respto, I_PutM_branch_respto) {
    a_I_PutM_I_PutM_branch_respto;
    queueBranch_respto;
  }
  
  transition(I_PutM_branch_respto, branchOutcome_1, I_PutM_COND_ownerPutMsrc_I) {
    a_sendMemWrite_respto;
    a_poprespto;
    a_popcondq;
  }
  transition(I_PutM_branch_respto, branchOutcome_2, I) {
    a_poprespto;
    a_popcondq;
  }
  transition(M, PutM_respto, M_PutM_branch_respto) {
    a_I_PutM_I_PutM_branch_respto;
    queueBranch_respto;
  }
  
  transition(M_PutM_branch_respto, branchOutcome_1, M_PutM_COND_ownerPutMsrc_I) {
    a_sendMemWrite_respto;
    a_poprespto;
    a_popcondq;
  }
  transition(M_PutM_branch_respto, branchOutcome_2, M) {
    a_poprespto;
    a_popcondq;
  }
  transition(S, PutM_respto, S_PutM_branch_respto) {
    a_I_PutM_I_PutM_branch_respto;
    queueBranch_respto;
  }
  
  transition(S_PutM_branch_respto, branchOutcome_1, S_PutM_COND_ownerPutMsrc_S) {
    a_sendMemWrite_respto;
    a_poprespto;
    a_popcondq;
  }
  transition(S_PutM_branch_respto, branchOutcome_2, S) {
    a_poprespto;
    a_popcondq;
  }

  transition(I, PutS_respto, I) {
    a_I_PutS_I_respto;
    a_poprespto;
  }
  transition(M, PutS_respto, M) {
    a_I_PutS_I_respto;
    a_poprespto;
  }

  transition(M, GetM_respto, M) {
    a_M_GetM_M_respto;
    a_poprespto;
  }

  transition(M, GetS_respto, M_GetS) {
    a_M_GetS_M_GetS_respto;
    a_poprespto;
  }

  transition(M_GetS, WB_respto, M_GetS_WB_branch_respto) {
    queueBranch_respto;
  }

  transition(M_GetS_WB_branch_respto, branchOutcome_1, M_GetS_WB_COND_WBsrcowner_S) {
    a_sendMemWrite_respto;
    a_poprespto;
    a_popcondq;
  }
  transition(M_GetS_WB_branch_respto, branchOutcome_2, M_GetS) {
    a_poprespto;
    a_popcondq;
  }

  transition(S, GetM_respto, S_GetM_branch_respto) {
    queueBranch_respto;
  }
  transition(S_GetM_branch_respto, branchOutcome_1, S_GetM_COND_SETFUNC_cachecontainsUpgradesrc_M) {
    a_sendMemRead_respto;
    a_poprespto;
    a_popcondq;
  }
  transition(S_GetM_branch_respto, branchOutcome_2, S_GetM_NCOND_SETFUNC_cachecontainsUpgradesrc_M) {
    a_sendMemRead_respto;
    a_poprespto;
    a_popcondq;
  }

  transition(S, GetS_respto, S_GetS__S) {
    a_sendMemRead_respto;
    a_poprespto;
  }

  transition(S, PutS_respto, S_PutS_branch_respto) {
    a_S_PutS_S_PutS_branch_respto;
    queueBranch_respto;
  }
  transition(S_PutS_branch_respto, branchOutcome_1, I) {
    a_poprespto;
    a_popcondq;
  }
  transition(S_PutS_branch_respto, branchOutcome_2, S) {
    a_poprespto;
    a_popcondq;
  }
  transition(I, GetM_fwdto, I_GetM__M) {
    a_sendMemRead_fwdto;
    a_popfwdto;
  }
  transition(I, GetS_fwdto, I_GetS__S) {
    a_sendMemRead_fwdto;
    a_popfwdto;
  }

  transition(I, PutM_fwdto, I_PutM_branch_fwdto) {
    a_I_PutM_I_PutM_branch_fwdto;
    queueBranch_fwdto;
  }
  
  transition(I_PutM_branch_fwdto, branchOutcome_1, I_PutM_COND_ownerPutMsrc_I) {
    a_sendMemWrite_fwdto;
    a_popfwdto;
    a_popcondq;
  }
  transition(I_PutM_branch_fwdto, branchOutcome_2, I) {
    a_popfwdto;
    a_popcondq;
  }
  transition(M, PutM_fwdto, M_PutM_branch_fwdto) {
    a_I_PutM_I_PutM_branch_fwdto;
    queueBranch_fwdto;
  }
  
  transition(M_PutM_branch_fwdto, branchOutcome_1, M_PutM_COND_ownerPutMsrc_I) {
    a_sendMemWrite_fwdto;
    a_popfwdto;
    a_popcondq;
  }
  transition(M_PutM_branch_fwdto, branchOutcome_2, M) {
    a_popfwdto;
    a_popcondq;
  }
  transition(S, PutM_fwdto, S_PutM_branch_fwdto) {
    a_I_PutM_I_PutM_branch_fwdto;
    queueBranch_fwdto;
  }
  
  transition(S_PutM_branch_fwdto, branchOutcome_1, S_PutM_COND_ownerPutMsrc_S) {
    a_sendMemWrite_fwdto;
    a_popfwdto;
    a_popcondq;
  }
  transition(S_PutM_branch_fwdto, branchOutcome_2, S) {
    a_popfwdto;
    a_popcondq;
  }

  transition(I, PutS_fwdto, I) {
    a_I_PutS_I_fwdto;
    a_popfwdto;
  }
  transition(M, PutS_fwdto, M) {
    a_I_PutS_I_fwdto;
    a_popfwdto;
  }

  transition(M, GetM_fwdto, M) {
    a_M_GetM_M_fwdto;
    a_popfwdto;
  }

  transition(M, GetS_fwdto, M_GetS) {
    a_M_GetS_M_GetS_fwdto;
    a_popfwdto;
  }

  transition(M_GetS, WB_fwdto, M_GetS_WB_branch_fwdto) {
    queueBranch_fwdto;
  }

  transition(M_GetS_WB_branch_fwdto, branchOutcome_1, M_GetS_WB_COND_WBsrcowner_S) {
    a_sendMemWrite_fwdto;
    a_popfwdto;
    a_popcondq;
  }
  transition(M_GetS_WB_branch_fwdto, branchOutcome_2, M_GetS) {
    a_popfwdto;
    a_popcondq;
  }

  transition(S, GetM_fwdto, S_GetM_branch_fwdto) {
    queueBranch_fwdto;
  }
  transition(S_GetM_branch_fwdto, branchOutcome_1, S_GetM_COND_SETFUNC_cachecontainsUpgradesrc_M) {
    a_sendMemRead_fwdto;
    a_popfwdto;
    a_popcondq;
  }
  transition(S_GetM_branch_fwdto, branchOutcome_2, S_GetM_NCOND_SETFUNC_cachecontainsUpgradesrc_M) {
    a_sendMemRead_fwdto;
    a_popfwdto;
    a_popcondq;
  }

  transition(S, GetS_fwdto, S_GetS__S) {
    a_sendMemRead_fwdto;
    a_popfwdto;
  }

  transition(S, PutS_fwdto, S_PutS_branch_fwdto) {
    a_S_PutS_S_PutS_branch_fwdto;
    queueBranch_fwdto;
  }
  transition(S_PutS_branch_fwdto, branchOutcome_1, I) {
    a_popfwdto;
    a_popcondq;
  }
  transition(S_PutS_branch_fwdto, branchOutcome_2, S) {
    a_popfwdto;
    a_popcondq;
  }
  transition(I, GetM_reqto, I_GetM__M) {
    a_sendMemRead_reqto;
    a_popreqto;
  }
  transition(I, GetS_reqto, I_GetS__S) {
    a_sendMemRead_reqto;
    a_popreqto;
  }

  transition(I, PutM_reqto, I_PutM_branch_reqto) {
    a_I_PutM_I_PutM_branch_reqto;
    queueBranch_reqto;
  }
  
  transition(I_PutM_branch_reqto, branchOutcome_1, I_PutM_COND_ownerPutMsrc_I) {
    a_sendMemWrite_reqto;
    a_popreqto;
    a_popcondq;
  }
  transition(I_PutM_branch_reqto, branchOutcome_2, I) {
    a_popreqto;
    a_popcondq;
  }
  transition(M, PutM_reqto, M_PutM_branch_reqto) {
    a_I_PutM_I_PutM_branch_reqto;
    queueBranch_reqto;
  }
  
  transition(M_PutM_branch_reqto, branchOutcome_1, M_PutM_COND_ownerPutMsrc_I) {
    a_sendMemWrite_reqto;
    a_popreqto;
    a_popcondq;
  }
  transition(M_PutM_branch_reqto, branchOutcome_2, M) {
    a_popreqto;
    a_popcondq;
  }
  transition(S, PutM_reqto, S_PutM_branch_reqto) {
    a_I_PutM_I_PutM_branch_reqto;
    queueBranch_reqto;
  }
  
  transition(S_PutM_branch_reqto, branchOutcome_1, S_PutM_COND_ownerPutMsrc_S) {
    a_sendMemWrite_reqto;
    a_popreqto;
    a_popcondq;
  }
  transition(S_PutM_branch_reqto, branchOutcome_2, S) {
    a_popreqto;
    a_popcondq;
  }

  transition(I, PutS_reqto, I) {
    a_I_PutS_I_reqto;
    a_popreqto;
  }
  transition(M, PutS_reqto, M) {
    a_I_PutS_I_reqto;
    a_popreqto;
  }

  transition(M, GetM_reqto, M) {
    a_M_GetM_M_reqto;
    a_popreqto;
  }

  transition(M, GetS_reqto, M_GetS) {
    a_M_GetS_M_GetS_reqto;
    a_popreqto;
  }

  transition(M_GetS, WB_reqto, M_GetS_WB_branch_reqto) {
    queueBranch_reqto;
  }

  transition(M_GetS_WB_branch_reqto, branchOutcome_1, M_GetS_WB_COND_WBsrcowner_S) {
    a_sendMemWrite_reqto;
    a_popreqto;
    a_popcondq;
  }
  transition(M_GetS_WB_branch_reqto, branchOutcome_2, M_GetS) {
    a_popreqto;
    a_popcondq;
  }

  transition(S, GetM_reqto, S_GetM_branch_reqto) {
    queueBranch_reqto;
  }
  transition(S_GetM_branch_reqto, branchOutcome_1, S_GetM_COND_SETFUNC_cachecontainsUpgradesrc_M) {
    a_sendMemRead_reqto;
    a_popreqto;
    a_popcondq;
  }
  transition(S_GetM_branch_reqto, branchOutcome_2, S_GetM_NCOND_SETFUNC_cachecontainsUpgradesrc_M) {
    a_sendMemRead_reqto;
    a_popreqto;
    a_popcondq;
  }

  transition(S, GetS_reqto, S_GetS__S) {
    a_sendMemRead_reqto;
    a_popreqto;
  }

  transition(S, PutS_reqto, S_PutS_branch_reqto) {
    a_S_PutS_S_PutS_branch_reqto;
    queueBranch_reqto;
  }
  transition(S_PutS_branch_reqto, branchOutcome_1, I) {
    a_popreqto;
    a_popcondq;
  }
  transition(S_PutS_branch_reqto, branchOutcome_2, S) {
    a_popreqto;
    a_popcondq;
  }

  // DMA EVENTS IN I
  //// DMA_WRITE
  transition(I, DMA_WRITE, I_DMA_WRITE_I) {
    a_allocate_TBE_for_DMA;
    a_sendPartialMemoryWB_reqto;
    a_popreqto;
  }
  transition(I_DMA_WRITE_I, Memory_Write, I) {
    a_send_DMA_ACK;
    a_deallocate_TBE;
    a_popmemq;
  }
  //// DMA_READ
  transition(I, DMA_READ, I_DMA_READ_I) {
    a_sendMemRead_reqto;
    a_popreqto;
  }
  transition(I_DMA_READ_I, Memory_Read, I) {
    a_I_DMA_READ;
    a_popmemq;
  }

  // DMA EVENTS IN S
  //// DMA_WRITE
  transition(S, DMA_WRITE, S_DMA_WRITE) {
    a_allocate_TBE_for_DMA;
    a_S_DMA_WRITE;
    a_popreqto;
  }

  transition(S_DMA_WRITE, DMA_ALL_ACKS, S_DMA_I) {
    a_sendPartialMemoryWB_respto;
    a_poprespto;
  }

  transition(S_DMA_I, Memory_Write, I) {
    a_send_DMA_ACK;
    a_deallocate_TBE;
    a_popmemq;
  }
  //// DMA_READ
  transition(S, DMA_READ, S_DMA_READ_S) {
    a_sendMemRead_reqto;
    a_popreqto;
  }
  transition(S_DMA_READ_S, Memory_Read, S) {
    a_I_DMA_READ;
    a_popmemq;
  }

  // DMA EVENTS IN M
  //// DMA_WRITE
  transition(M, DMA_WRITE, M_DMA_WRITE) {
    a_allocate_TBE_for_DMA;
    a_send_Fwd_GetM;
    a_popreqto;
  }
  transition(M_DMA_WRITE, GetM_Ack_D, M_DMA_WRITE_I) {
    a_sendPartialMemoryWB_GetM_Ack_D;
    a_poprespto;
  }
  transition(M_DMA_WRITE_I, Memory_Write, I) {
    a_send_DMA_ACK;
    a_deallocate_TBE;
    a_popmemq;
  }

  //// DMA_READ
  transition(M, DMA_READ, M_GetS) {
    a_M_DMA_READ;
    a_popreqto;
  }

  
  // STALL
  transition({
    M,
    S,
    M_GetS,
    I,
    I_GetM__M,
    I_GetS__S,
    I_PutM_COND_ownerPutMsrc_I,
    I_Upgrade__M,
    M_PutM_COND_ownerPutMsrc_I,
    M_GetS_WB_COND_WBsrcowner_S,
    S_GetM_COND_SETFUNC_cachecontainsUpgradesrc_M,
    S_GetM_NCOND_SETFUNC_cachecontainsUpgradesrc_M,
    S_GetS__S,
    S_PutM_COND_ownerPutMsrc_S,
    S_Upgrade_COND_SETFUNC_cachecontainsUpgradesrc_M,
    S_Upgrade_NCOND_SETFUNC_cachecontainsUpgradesrc_M,
    I_PutM_branch_respto,
    M_PutM_branch_respto,
    M_GetS_branch_respto,
    M_GetS_WB_branch_respto,
    S_GetM_branch_respto,
    S_PutS_branch_respto,
    S_PutM_branch_respto,
    I_PutM_branch_fwdto,
    M_PutM_branch_fwdto,
    M_GetS_branch_fwdto,
    M_GetS_WB_branch_fwdto,
    S_GetM_branch_fwdto,
    S_PutS_branch_fwdto,
    S_PutM_branch_fwdto,
    I_PutM_branch_reqto,
    M_PutM_branch_reqto,
    M_GetS_branch_reqto,
    M_GetS_WB_branch_reqto,
    S_GetM_branch_reqto,
    S_PutS_branch_reqto,
    S_PutM_branch_reqto,
    I_DMA_WRITE_I,
    I_DMA_READ_I,
    S_DMA_WRITE,
    S_DMA_I,
    S_DMA_READ_S,
    M_DMA_WRITE,
    M_DMA_WRITE_I
    }, Stall) {
      stall;
    }


}
// EOF
